---
title: "Developing a Machine Learning Pipeline for Crystallography Data"
author: "Don Ngo"
date: "`r Sys.Date()`"
output: pdf_document
---

# General Objectives

-   Create a private GitHub repository.
-   Extract information from crystallography files.
-   Identify necessary information for cluster analyses.
-   Build functions.
-   Build a package.

## Functions

### Set the working directory

```{r}
setwd("C:/repos/ml-crystals")
```

### List CIF files

```{r}
cif_list <- Sys.glob(paths = "data/*.cif")
cif_tab <- lapply(cif_list, readLines , warn =  FALSE)
```

### Packages (to be adjusted)

```{r}
library(data.table)
library(stringr)
library(dplyr)
```

### Bind CIF Files into One Table

```{r}
# List CIF files
cif_list <- Sys.glob(paths = "data/*.cif")
cif_tab <- lapply(cif_list, fread, sep = "\n", header = FALSE)
```

### Extracting Data

```{r}
# Function to extract a specific value based on a pattern from CIF content
extract_value <- function(cif_content, pattern, remove_pattern = TRUE) {
  # Find lines that match the given pattern
  lines <- cif_content[V1 %like% pattern]
  if (nrow(lines) > 0) {
    value <- lines$V1
    if (remove_pattern) {
      value <- gsub(pattern, "", value)
    }
    # Clean the value by removing quotes and trimming whitespace
    value <- gsub("'", "", value)
    value <- trimws(value)
    return(value)
  } else {
    return(NA)
  }
}
```

### Specific extraction functions for different properties

```{r}
extract_database_code <- function (cif_content) {
  extract_value(cif_content, "_database_code_")
}

extract_chemical_formula <- function(cif_content) {
  extract_value(cif_content, "_chemical_formula_sum")
}

extract_structure_type <- function(cif_content) {
  extract_value(cif_content, "_chemical_name_structure_type")
}

extract_space_group_name <- function(cif_content) {
  extract_value(cif_content, "_space_group_name_H-M_alt")
}

extract_space_group_number <- function(cif_content) {
  extract_value(cif_content, "_space_group_IT_number")
}
```

### Function to extract unit cell metrics

```{r}
extract_unit_cell_metrics <- function(cif_content) {
  cell_parameters <- c(
    "_cell_length_a",
    "_cell_length_b",
    "_cell_length_c",
    "_cell_angle_alpha",
    "_cell_angle_beta",
    "_cell_angle_gamma"
  )

  # Extract and clean values for each cell parameter
  values <- sapply(cell_parameters, function(param) {
    line <- cif_content[V1 %like% param]$V1
    if (length(line) > 0) {
      value <- gsub(".*\\s+([0-9\\.]+).*", "\\1", line)
      return(as.numeric(value))
    } else {
      return(NA)
    }
  })

  # Create a data table with the extracted values
  unit_cell_metrics <- as.data.table(t(values))
  setnames(unit_cell_metrics, cell_parameters)
  
  return(unit_cell_metrics)
}
```

### Extracting atomic coordinates

```{r}
extract_atomic_coordinates <- function(cif_content) {
  labels <- vector()
  fractional_x <- vector()
  fractional_y <- vector()
  fractional_z <- vector()
  x_errors <- vector()
  y_errors <- vector()
  z_errors <- vector()

  scale_error <- function(value, error) {
    if (is.na(error)) return(NA)
    decimal_places <- nchar(strsplit(as.character(value), "\\.")[[1]][2])
    scaled_error <- as.numeric(paste0("0.", strrep("0", decimal_places - nchar(error)), error))
    return(scaled_error)
  }

  atom_start <- grep("_atom_site_occupancy", cif_content$V1)
  if (length(atom_start) == 0) return(NULL)

  section_end_candidates <- c(
    grep("^loop_", cif_content$V1[(atom_start + 1):nrow(cif_content)]),
    grep("^\\s*$", cif_content$V1[(atom_start + 1):nrow(cif_content)])  # Detect blank lines
  )
  
  if (length(section_end_candidates) > 0) {
    atom_end <- min(section_end_candidates) + atom_start  # Get first occurrence
  } else {
    atom_end <- nrow(cif_content)  # Default to end of file
  }

  for (line in cif_content$V1[(atom_start + 1):(atom_end - 1)]) {
    properties <- strsplit(line, "\\s+")[[1]]

    labels <- c(labels, as.character(properties[1]))

    fractional_x_val <- gsub("\\(.*\\)", "", properties[5])
    fractional_y_val <- gsub("\\(.*\\)", "", properties[6])
    fractional_z_val <- gsub("\\(.*\\)", "", properties[7])

    x_error <- ifelse(grepl("\\(", properties[5]), gsub(".*\\((.*)\\).*", "\\1", properties[5]), NA)
    y_error <- ifelse(grepl("\\(", properties[6]), gsub(".*\\((.*)\\).*", "\\1", properties[6]), NA)
    z_error <- ifelse(grepl("\\(", properties[7]), gsub(".*\\((.*)\\).*", "\\1", properties[7]), NA)

    fractional_x <- c(fractional_x, fractional_x_val)
    fractional_y <- c(fractional_y, fractional_y_val)
    fractional_z <- c(fractional_z, fractional_z_val)

    x_errors <- c(x_errors, scale_error(fractional_x_val, x_error))
    y_errors <- c(y_errors, scale_error(fractional_y_val, y_error))
    z_errors <- c(z_errors, scale_error(fractional_z_val, z_error))
  }

  atomic_coordinates <- data.table(
    Label = labels,
    x_a = as.numeric(fractional_x),
    y_b = as.numeric(fractional_y),
    z_c = as.numeric(fractional_z),
    x_error = as.numeric(x_errors),
    y_error = as.numeric(y_errors),
    z_error = as.numeric(z_errors)
  )

  return(atomic_coordinates)
}
```

### Function to extract symmetry operations from CIF content

```{r}
extract_symmetry_operations <- function(cif_content) {
  symmetry_start <- grep("_space_group_symop_operation_xyz", cif_content$V1)
  if (length(symmetry_start) == 0) return(NULL)

  section_end_candidates <- c(
    grep("^loop_", cif_content$V1[(symmetry_start + 1):nrow(cif_content)]),
    grep("^\\s*$", cif_content$V1[(symmetry_start + 1):nrow(cif_content)])  # Detect blank lines
  )
  
  if (length(section_end_candidates) > 0) {
    symmetry_end <- min(section_end_candidates) + symmetry_start
  } else {
    symmetry_end <- nrow(cif_content)
  }

  symmetry_lines <- cif_content$V1[(symmetry_start + 1):(symmetry_end - 1)]
  
  # Remove leading numeric labels and potential extra spaces
  symmetry_lines <- gsub("^[0-9]+\\s+", "", symmetry_lines)
  
  # Split each line into components
  symmetry_operations <- str_split_fixed(symmetry_lines, ",\\s*", n = 3)

  # Create a data table with the extracted symmetry operations
  symmetry_operations <- data.table(
    x = gsub("'", "", symmetry_operations[, 1]),
    y = gsub("'", "", symmetry_operations[, 2]),
    z = gsub("'", "", symmetry_operations[, 3])
  )

  return(symmetry_operations)
}
```

### Function to apply symmetry operations to atomic coordinates

```{r}
apply_symmetry_operations <- function(atomic_coordinates, symmetry_operations) {
  # Helper function to apply a single operation
  apply_operation <- function(operation, x, y, z) {
    operation <- gsub("x", sprintf("(%f)", x), operation)
    operation <- gsub("y", sprintf("(%f)", y), operation)
    operation <- gsub("z", sprintf("(%f)", z), operation)
    eval(parse(text = operation))
  }

  # Expand coordinates by applying each symmetry operation
  expand_coordinates <- function(row) {
    x <- row$x_a
    y <- row$y_b
    z <- row$z_c
    new_coords <- rbindlist(lapply(1:nrow(symmetry_operations), function(i) {
      new_x <- apply_operation(symmetry_operations[i, x], x, y, z)
      new_y <- apply_operation(symmetry_operations[i, y], x, y, z)
      new_z <- apply_operation(symmetry_operations[i, z], x, y, z)

      data.table(
        Label = paste(row$Label, i, sep = "_"), # Apply unique label
        #Regular label
        #Label = row$Label,
        x_a = ifelse(new_x > 1, new_x - 1, ifelse(new_x < 0, new_x + 1, new_x)),
        y_b = ifelse(new_y > 1, new_y - 1, ifelse(new_y < 0, new_y + 1, new_y)),
        z_c = ifelse(new_z > 1, new_z - 1, ifelse(new_z < 0, new_z + 1, new_z))
      )
    }))
    return(new_coords)
  }

  # Apply symmetry operations to all atomic coordinates
  transformed_coords <- rbindlist(lapply(1:nrow(atomic_coordinates), function(i) {
    expand_coordinates(atomic_coordinates[i])
  }))

  # Remove duplicates
  transformed_coords <- transformed_coords %>%
    distinct(x_a, y_b, z_c, .keep_all = TRUE)

  return(transformed_coords)
}
```

### Function to expand transformed coordinates in all neighboring unit cells

```{r}
expand_transformed_coords <- function(transformed_coords) {
  # Define the number of unit cells to expand in each direction
  n_cells <- 1

  # Generate a grid of unit cell indices to expand
  cell_indices <- as.data.table(expand.grid(
    x = -n_cells:n_cells,
    y = -n_cells:n_cells,
    z = -n_cells:n_cells
  ))

  # Expand the transformed coordinates
  expanded_coords <- rbindlist(lapply(1:nrow(cell_indices), function(i) {
    cell_shift <- cell_indices[i]
    new_coords <- transformed_coords[, .(
      Label = paste(Label, paste(cell_shift$x, cell_shift$y, cell_shift$z, sep = "_"), sep = "_"),
      #Regular label
      #Label = Label,
      x_a = x_a + cell_shift$x,
      y_b = y_b + cell_shift$y,
      z_c = z_c + cell_shift$z
    )]
    return(new_coords)
  }))

  # Remove duplicates
  expanded_coords <- expanded_coords %>%
    distinct(x_a, y_b, z_c, .keep_all = TRUE)

  return(expanded_coords)
}
```

### Function to calculate distances between atoms using real-space metric tensor and vectorization

```{r}
calculate_distances <- function(atomic_coordinates, expanded_coords, unit_cell_metrics) {
  # Extract unit cell parameters
  a <- unit_cell_metrics$`_cell_length_a`
  b <- unit_cell_metrics$`_cell_length_b`
  c <- unit_cell_metrics$`_cell_length_c`
  alpha <- unit_cell_metrics$`_cell_angle_alpha` * pi / 180  # Convert to radians
  beta <- unit_cell_metrics$`_cell_angle_beta` * pi / 180    # Convert to radians
  gamma <- unit_cell_metrics$`_cell_angle_gamma` * pi / 180  # Convert to radians

  # Extract coordinates as matrices
  coords_atomic <- as.matrix(atomic_coordinates[, .(x_a, y_b, z_c)])
  coords_expanded <- as.matrix(expanded_coords[, .(x_a, y_b, z_c)])
  #coords_expanded <- as.matrix(rbind(atomic_coordinates[, .(x_a, y_b, z_c)],                              expanded_coords[, .(x_a, y_b, z_c)]))
  labels_atomic <- atomic_coordinates$Label
  labels_expanded <- expanded_coords$Label

  # Calculate pairwise differences in coordinates between atomic and transformed coordinates
  delta_x <- outer(coords_atomic[, 1], coords_expanded[, 1], "-")
  delta_y <- outer(coords_atomic[, 2], coords_expanded[, 2], "-")
  delta_z <- outer(coords_atomic[, 3], coords_expanded[, 3], "-")

  # Cosine terms for angles
  cos_alpha <- cos(alpha)
  cos_beta <- cos(beta)
  cos_gamma <- cos(gamma)
  
  # Set near-zero cosine values to exactly 0
  if (abs(cos_alpha) < 1e-10) cos_alpha <- 0
  if (abs(cos_beta) < 1e-10) cos_beta <- 0
  if (abs(cos_gamma) < 1e-10) cos_gamma <- 0

  # Calculate the squared distance using the metric tensor
  r2 <- ((a^2) * (delta_x^2)) + ((b^2) * (delta_y^2)) + ((c^2) * (delta_z^2)) +
        (2 * b * c * cos_alpha * delta_y * delta_z) +
        (2 * c * a * cos_beta * delta_z * delta_x) +
        (2 * a * b * cos_gamma * delta_x * delta_y)

  # Calculate the distances
  r <- sqrt(r2)

  # Create a distance matrix with atom labels
  atom_pairs <- expand.grid(Atom1 = labels_atomic, Atom2 = labels_expanded, KEEP.OUT.ATTRS = TRUE)

  distances <- data.table(
    Atom1 = atom_pairs$Atom1,
    Atom2 = atom_pairs$Atom2,
    Distance = as.vector(r),
    DeltaX = as.vector(delta_x),
    DeltaY = as.vector(delta_y),
    DeltaZ = as.vector(delta_z),
    CosAlpha = as.vector(cos_alpha),
    CosBeta = as.vector(cos_beta),
    CosGamma = as.vector(cos_gamma)
  )

  distances <- distances[Distance > 0]
  # Filter out distances above 10 Angstrom if necessary
  # distances <- distances[Distance > 0.01 & Distance < 10]

  return(distances)
}

```

### Function to apply Minimum Distance Method

```{r}
minimum_distance <- function(distances, delta = 0.1) {
  # Calculate dmin for each Atom1
  dmin <- distances[, .(dmin = min(Distance)), by = .(Atom1)]
  
  # Calculate dcut for each Atom1
  dmin[, dcut := (1 + delta) * dmin, print(Atom1)]
  
  # Determine bonded pairs based on dcut
  bonded_pairs <- distances[dmin, on = .(Atom1), allow.cartesian = TRUE][Distance <= dcut, .(Atom1, Atom2, Distance, dcut, dmin)]
  
  # Remove duplicates
  # unique_bonds <- bonded_pairs %>%
  #   distinct(Distance, .keep_all = TRUE)
  
  return(bonded_pairs)
  
}
```

### Function to apply Brunner's Largest Reciprocal Gap Method

```{r}
brunner <- function(distances, delta = 0.0001) {
  # Initialize an empty list to store the bonds
  bonds <- list()
  
  # Iterate over each unique central atom in the distances table
  unique_atoms <- unique(distances$Atom1)
  for (atom in unique_atoms) {
    # Filter distances for the current Atom1 and order by distance
    atom_distances <- distances[Atom1 == atom][order(Distance)]
    
    # Initialize the largest reciprocal gap and the corresponding index
    largest_gap <- -Inf
    j_max <- NA
    
    # Calculate the largest reciprocal gap
    for (j in 1:(nrow(atom_distances) - 1)) {
      reciprocal_gap <- 1 / atom_distances$Distance[j] - 1 / atom_distances$Distance[j + 1]
      if (reciprocal_gap > largest_gap) {
        largest_gap <- reciprocal_gap
        j_max <- j
      }
    }
    
    # Determine the distance cut-off
    d_cut <- atom_distances$Distance[j_max] + delta
    
    # Select the bonds within the distance cut-off
    bonded_atoms <- atom_distances[Distance <= d_cut]
    
    # Store the bonds for the current atom
    bonds[[atom]] <- bonded_atoms
  }
  
  # Combine all bonds into a single data.table
  bonds <- rbindlist(bonds, fill = TRUE)
  return(bonds)
}
```

### Function to apply Hoppe's Method of Effective Coordination Numbers

```{r}
hoppe <- function(distances, delta = 0.5, tolerance = 0.001) {
  # Initialize an empty list to store the bonded pairs
  bonded_pairs <- list()
  
  # Iterate over each unique Atom1 in the distances table
  unique_atoms <- unique(distances$Atom1)
  for (atom in unique_atoms) {
    # Filter distances for the current Atom1
    atom_distances <- distances[Atom1 == atom]

    # Step 1: Calculate dmin for the current atom
    dmin <- min(atom_distances$Distance)
    
    # Step 2: Calculate initial davg (0davg)
    davg <- sum(atom_distances$Distance * exp(1 - (atom_distances$Distance / dmin)^6)) / 
            sum(exp(1 - (atom_distances$Distance / dmin)^6))
    
    # Step 3: Iteratively calculate ndavg until convergence
    ndavg <- davg
    while (TRUE) {
      prev_davg <- davg
      davg <- sum(atom_distances$Distance * exp(1 - (atom_distances$Distance / prev_davg)^6)) / 
              sum(exp(1 - (atom_distances$Distance / prev_davg)^6))
      if (abs(davg - prev_davg) <= tolerance) break
    }
    
    # Step 4: Determine bonded pairs and their bond strength based on the tolerance parameter δ
    atom_distances[, BondStrength := exp(1 - (Distance / davg)^6)]
    bonded <- atom_distances[BondStrength >= delta, .(Atom1, Atom2, Distance)]
    bonded_pairs[[atom]] <- bonded
  }
  
  # Combine all bonded pairs into a single data.table
  bonded_pairs <- rbindlist(bonded_pairs, fill = TRUE)
  return(bonded_pairs)
}
```

#### Function to calculate the number of nearest neighbors for each atom

```{r}
calculate_neighbor_counts <- function(bonded_pairs_table) {
  # Check if the input table is NULL or empty
  if (is.null(bonded_pairs_table) || nrow(bonded_pairs_table) == 0) {
    # Return an empty table with the correct structure if no bonds are found
    return(data.table(Atom = character(), NeighborCount = integer()))
  }
  
  # Group by Atom1 (the central atom) and count the number of neighbors (Atom2)
  # .N is a data.table special symbol for the number of rows in a group
  neighbor_counts <- bonded_pairs_table[, .(NeighborCount = .N), by = .(Atom1)]
  
  # Rename Atom1 to Atom for clarity in the output table
  setnames(neighbor_counts, "Atom1", "Atom")
  
  return(neighbor_counts)
}
```

### Calculate Bond Angles

```{r}
calculate_angles <- function(bonded_pairs, atomic_coordinates, expanded_coords, unit_cell_metrics) {
  # Extract unit cell parameters once
  a <- unit_cell_metrics$`_cell_length_a`
  b <- unit_cell_metrics$`_cell_length_b`
  c <- unit_cell_metrics$`_cell_length_c`
  alpha_rad <- unit_cell_metrics$`_cell_angle_alpha` * pi / 180
  beta_rad <- unit_cell_metrics$`_cell_angle_beta` * pi / 180
  gamma_rad <- unit_cell_metrics$`_cell_angle_gamma` * pi / 180

  # Pre-calculate cosines, handling potential near-zero values if necessary
  cos_alpha <- cos(alpha_rad)
  cos_beta <- cos(beta_rad)
  cos_gamma <- cos(gamma_rad)
  # Set near-zero cosine values to exactly 0 if needed
  # if (abs(cos_alpha) < 1e-10) cos_alpha <- 0
  # if (abs(cos_beta) < 1e-10) cos_beta <- 0
  # if (abs(cos_gamma) < 1e-10) cos_gamma <- 0

  # Combine original and expanded coordinates for easier lookup
  all_coords <- rbind(
      atomic_coordinates[, .(Label, x_a, y_b, z_c)],
      expanded_coords[, .(Label, x_a, y_b, z_c)],
      fill = TRUE # Use fill=TRUE in case error columns exist in one but not the other
    )[, .(Label, x_a, y_b, z_c)] # Ensure only necessary columns are kept
  # Ensure no duplicate labels exist if an original atom overlaps with an expanded one at 0,0,0 shift
  all_coords <- unique(all_coords, by = "Label") 
  setkey(all_coords, Label) # Set key for faster lookups

  # Helper function to calculate angle using metric tensor
  calculate_angle_metric <- function(atom1_label, atom2_label, atom3_label) {
    # Get fractional coordinates
    coord1 <- all_coords[atom1_label, .(x_a, y_b, z_c)]
    coord2 <- all_coords[atom2_label, .(x_a, y_b, z_c)]
    coord3 <- all_coords[atom3_label, .(x_a, y_b, z_c)]

    # Check if coordinates were found
    if (anyNA(coord1) || anyNA(coord2) || anyNA(coord3)) {
       warning(paste("Coordinates not found for one or more atoms in angle:", atom1_label, atom2_label, atom3_label))
       return(NA_real_)
    }
    
    # Calculate fractional difference vectors v1 = coord2 - coord1, v2 = coord3 - coord1
    v1_frac <- as.numeric(coord2 - coord1) # (xf1, yf1, zf1)
    v2_frac <- as.numeric(coord3 - coord1) # (xf2, yf2, zf2)

    xf1 <- v1_frac[1]; yf1 <- v1_frac[2]; zf1 <- v1_frac[3]
    xf2 <- v2_frac[1]; yf2 <- v2_frac[2]; zf2 <- v2_frac[3]

    # Calculate dot product using metric tensor components
    dot_product <- (xf1 * xf2 * a^2 +
                    yf1 * yf2 * b^2 +
                    zf1 * zf2 * c^2 +
                    (xf1 * yf2 + yf1 * xf2) * a * b * cos_gamma +
                    (xf1 * zf2 + zf1 * xf2) * a * c * cos_beta + # Corrected term
                    (yf1 * zf2 + zf1 * yf2) * b * c * cos_alpha)

    # Calculate squared magnitudes using metric tensor components
    mag_sq1 <- (xf1^2 * a^2 + yf1^2 * b^2 + zf1^2 * c^2 +
                2 * xf1 * yf1 * a * b * cos_gamma +
                2 * xf1 * zf1 * a * c * cos_beta +
                2 * yf1 * zf1 * b * c * cos_alpha)

    mag_sq2 <- (xf2^2 * a^2 + yf2^2 * b^2 + zf2^2 * c^2 +
                2 * xf2 * yf2 * a * b * cos_gamma +
                2 * xf2 * zf2 * a * c * cos_beta +
                2 * yf2 * zf2 * b * c * cos_alpha)

    # Avoid division by zero or sqrt of negative (due to floating point issues)
    if (mag_sq1 <= 1e-10 || mag_sq2 <= 1e-10) {
       warning(paste("Magnitude zero for vector in angle:", atom1_label, atom2_label, atom3_label))
       return(NA_real_) # Or potentially 0 or 180 depending on context
    }

    mag1 <- sqrt(mag_sq1)
    mag2 <- sqrt(mag_sq2)

    # Calculate cosine of the angle
    cos_theta <- dot_product / (mag1 * mag2)

    # Clamp cos_theta to [-1, 1] due to potential floating-point inaccuracies
    cos_theta <- min(max(cos_theta, -1.0), 1.0)

    # Calculate angle in degrees
    angle_deg <- acos(cos_theta) * 180 / pi

    return(angle_deg)
  }

  # --- Main loop to find angles ---
  
  # Initialize a list to store the angles
  angle_list <- list()

  # Find unique central atoms (Atom1 in the bonded pairs)
  unique_central_atoms <- unique(bonded_pairs$Atom1)

  # Loop through each central atom
  for (central_atom in unique_central_atoms) {
    # Find all atoms bonded to the current central atom
    bonded_neighbors <- bonded_pairs[Atom1 == central_atom, Atom2]

    # Need at least two neighbors to form an angle
    if (length(bonded_neighbors) >= 2) {
      # Generate unique combinations of two neighbors
      neighbor_combinations <- combn(bonded_neighbors, 2, simplify = FALSE) # Get list of pairs

      # Loop through each combination (triplet: neighbor1, central_atom, neighbor2)
      for (pair in neighbor_combinations) {
        atom2 <- pair[1]
        atom3 <- pair[2]

        # Calculate the bond angle using the metric tensor method
        angle <- calculate_angle_metric(central_atom, atom2, atom3)

        # Append the result to the list if angle is valid
        if (!is.na(angle)) {
          angle_list[[length(angle_list) + 1]] <- data.table(
            CentralAtom = central_atom,
            Neighbor1 = atom2,
            Neighbor2 = atom3,
            Angle = angle
          )
        }
      }
    }
  }

  # Combine all angle results into a single data table
  if (length(angle_list) > 0) {
      angle_results <- rbindlist(angle_list)
      # Optional: Order results for consistency
      angle_results <- angle_results[order(CentralAtom, Neighbor1, Neighbor2)]
  } else {
      # Return empty table with correct columns if no angles found
      angle_results <- data.table(CentralAtom=character(), Neighbor1=character(), Neighbor2=character(), Angle=numeric())
  }
  
  return(angle_results)
}
```

### Final Processing

```{r}
# Initialize an empty data table to store the results
main_table <- data.table()

# Iterate over each CIF content
for (cif in cif_tab) {
  # Extract various properties and metrics
  database_code <- extract_database_code(cif)
  chemical_formula <- extract_chemical_formula(cif)
  structure_type <- extract_structure_type(cif)
  space_group_name <- extract_space_group_name(cif)
  space_group_number <- extract_space_group_number(cif)
  unit_cell_metrics <- extract_unit_cell_metrics(cif)
  atomic_coordinates <- extract_atomic_coordinates(cif)
  symmetry_operations <- extract_symmetry_operations(cif)
  transformed_coords <- apply_symmetry_operations(atomic_coordinates, symmetry_operations)
  expanded_coords <- expand_transformed_coords(transformed_coords)
  distances <- calculate_distances(atomic_coordinates, expanded_coords, unit_cell_metrics)

  # Apply the coordination number prediction algorithms
  bonded_pairs <- minimum_distance(distances)
  neighbor_counts <- calculate_neighbor_counts(bonded_pairs)

  # Calculate bond angles for different bonded pairs
  bond_angles <- calculate_angles(bonded_pairs, atomic_coordinates, expanded_coords, unit_cell_metrics)
  
  # Combine extracted data into the main table
  main_table <- rbindlist(list(main_table, data.table(
    database_code = database_code,
    chemical_formula = chemical_formula,
    structure_type = structure_type,
    space_group_name = space_group_name,
    space_group_number = space_group_number,
    unit_cell_metrics = list(unit_cell_metrics),
    atomic_coordinates = list(atomic_coordinates),
    symmetry_operations = list(symmetry_operations),
    transformed_coords = list(transformed_coords),
    expanded_coords = list(expanded_coords),
    distances = list(distances),
    bonded_pairs = list(bonded_pairs),
    neighbor_counts = list(neighbor_counts),
    bond_angles = list(bond_angles)
  )), fill = TRUE)
}
```


