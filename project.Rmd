---
title: "Developing a Machine Learning Pipeline for Crystallography Data"
author: "Don Ngo"
date: "`r Sys.Date()`"
output: pdf_document
---

# General Objectives

-   Create a private GitHub repository.
-   Extract information from crystallography files.
-   Identify necessary information for cluster analyses.
-   Build functions.
-   Build a package.

## Functions

### Set the working directory

```{r}
setwd("C:/repos/ml-crystals")
```

### List CIF files

```{r}
cif_list <- Sys.glob(paths = "data/*.cif")
cif_tab <- lapply(cif_list, readLines , warn =  FALSE)
```

### Packages (to be adjusted)

```{r}
library(data.table)
library(stringr)
library(dplyr)
```

### Bind CIF Files into One Table

```{r}
# List CIF files
cif_list <- Sys.glob(paths = "data/*.cif")
cif_tab <- lapply(cif_list, fread, sep = "\n", header = FALSE)
```

### Extracting Data

```{r}
# --- Generic Value Extractor ---
# Description: Extracts a single value from CIF content based on a matching text pattern.
# Parameters:
#   - cif_content: A data.table containing the lines of a CIF file.
#   - pattern: The text pattern (e.g., "_database_code_") to search for.
#   - remove_pattern: A boolean indicating whether to remove the search pattern from the result.
# Returns:
#   - A character string of the cleaned value, or NA if not found.
extract_value <- function(cif_content, pattern, remove_pattern = TRUE) {
  # Find lines that match the given pattern
  lines <- cif_content[V1 %like% pattern]
  if (nrow(lines) > 0) {
    value <- lines$V1
    if (remove_pattern) {
      value <- gsub(pattern, "", value)
    }
    # Clean the value by removing quotes and trimming whitespace
    value <- gsub("'", "", value)
    value <- trimws(value)
    return(value)
  } else {
    return(NA)
  }
}
```

### Specific extraction functions for different properties

```{r}
# --- Specific Data Extraction Wrappers ---
# Description: A set of wrapper functions that use `extract_value` to get common
#              crystallographic properties from CIF content.
# Parameters:
#   - cif_content: A data.table containing the lines of a CIF file.
# Returns:
#   - A character string of the requested property, or NA if not found.

extract_database_code <- function (cif_content) {
  extract_value(cif_content, "_database_code_")
}

extract_chemical_formula <- function(cif_content) {
  extract_value(cif_content, "_chemical_formula_sum")
}

extract_structure_type <- function(cif_content) {
  extract_value(cif_content, "_chemical_name_structure_type")
}

extract_space_group_name <- function(cif_content) {
  extract_value(cif_content, "_space_group_name_H-M_alt")
}

extract_space_group_number <- function(cif_content) {
  extract_value(cif_content, "_space_group_IT_number")
}
```

### Function to extract unit cell metrics and their errors

```{r}
# --- Extract Unit Cell Metrics ---
# Description: Parses the unit cell parameters (lengths a, b, c and angles alpha, beta, gamma)
#              and their associated standard uncertainties from CIF content.
# Parameters:
#   - cif_content: A data.table containing the lines of a CIF file.
# Returns:
#   - A one-row data.table with columns for each cell parameter and its error.
extract_unit_cell_metrics <- function(cif_content) {
  cell_parameters <- c(
    "_cell_length_a",
    "_cell_length_b",
    "_cell_length_c",
    "_cell_angle_alpha",
    "_cell_angle_beta",
    "_cell_angle_gamma"
  )
  
  values <- list()
  errors <- list()
  
  # Helper function to parse the error from parentheses, e.g., 1.234(5) -> 0.005
  scale_error <- function(value_str, error_str) {
    if (is.na(error_str) || error_str == "")
      return(NA_real_)
    
    decimal_pos <- regexpr("\\.", value_str)
    
    if (decimal_pos == -1) {
      # If no decimal, the error applies to the last digit of the integer
      scaled_error <- as.numeric(error_str)
    } else {
      # If decimal exists, scale error based on number of decimal places
      decimal_places <- nchar(value_str) - decimal_pos
      scaled_error <- as.numeric(error_str) * 10^(-decimal_places)
    }
    
    return(scaled_error)
  }
  
  for (param in cell_parameters) {
    line <- cif_content[V1 %like% param]$V1
    if (length(line) > 0) {
      # Regex captures the value and the optional error in parentheses
      match <- str_match(line[1], "\\s+([0-9\\.]+)(?:\\(([0-9]+)\\))?")
      
      if (!is.na(match[1, 1])) {
        value_str <- match[1, 2]
        error_str <- match[1, 3] # The part inside the parentheses
        
        values[[param]] <- as.numeric(value_str)
        errors[[paste0(param, "_error")]] <- scale_error(value_str, error_str)
      } else {
        values[[param]] <- NA_real_
        errors[[paste0(param, "_error")]] <- NA_real_
      }
      
    } else {
      values[[param]] <- NA_real_
      errors[[paste0(param, "_error")]] <- NA_real_
    }
  }
  
  # Combine values and errors into a single data.table
  unit_cell_metrics <- as.data.table(c(values, errors))
  return(unit_cell_metrics)
}
```

### Extracting atomic coordinates

```{r}
# --- Extract Atomic Coordinates ---
# Description: Parses the atomic site information to extract the label, fractional
#              coordinates (x, y, z), and their standard uncertainties for each
#              asymmetric atom in the unit cell.
# Parameters:
#   - cif_content: A data.table containing the lines of a CIF file.
# Returns:
#   - A data.table where each row corresponds to an atom, with columns for Label,
#     x_a, y_b, z_c, and their corresponding errors (x_error, y_error, z_error).
extract_atomic_coordinates <- function(cif_content) {
  # --- 1. Find the start of the atom site loop (already efficient) ---
  first_header_line_idx <- grep("^_atom_site_fract_x", cif_content$V1)[1]
  if (is.na(first_header_line_idx)) {
    first_header_line_idx <- grep("^_atom_site_label", cif_content$V1)[1]
    if (is.na(first_header_line_idx))
      return(NULL)
  }
  loop_start_line_idx <- max(grep("^loop_", cif_content$V1[1:first_header_line_idx]))
  if (is.infinite(loop_start_line_idx))
    return(NULL)
  
  # --- 2. Read the headers and find column indices (already efficient) ---
  line_indices <- (loop_start_line_idx + 1):nrow(cif_content)
  headers <- character()
  first_data_line_idx <- 0
  for (i in line_indices) {
    line <- cif_content$V1[i]
    if (startsWith(line, "_")) {
      headers <- c(headers, trimws(line))
    } else {
      first_data_line_idx <- i
      break
    }
  }
  tags_to_find <- c(
    label = "_atom_site_label",
    x = "_atom_site_fract_x",
    y = "_atom_site_fract_y",
    z = "_atom_site_fract_z",
    occupancy = "_atom_site_occupancy",
    wyckoff = "_atom_site_Wyckoff_symbol",
    multiplicity = "_atom_site_symmetry_multiplicity"
  )
  col_indices <- sapply(tags_to_find, function(tag) {
    idx <- which(headers == tag)
    if (length(idx) == 0)
      NA
    else
      idx
  })
  if (is.na(col_indices["label"]) ||
      is.na(col_indices["x"]) ||
      is.na(col_indices["y"]) || is.na(col_indices["z"])) {
    warning("CIF file is missing essential atom site tags (_label, _fract_x, _y, _z).")
    return(NULL)
  }
  
  # --- 3. Find the end of the data block (already efficient) ---
  end_candidates <- c(grep("^loop_|^_|^#", cif_content$V1[first_data_line_idx:nrow(cif_content)]),
                      grep("^\\s*$", cif_content$V1[first_data_line_idx:nrow(cif_content)]))
  last_data_line_idx <- if (length(end_candidates) > 0) {
    first_data_line_idx + min(end_candidates) - 2
  } else {
    nrow(cif_content)
  }
  if (first_data_line_idx > last_data_line_idx)
    return(NULL)
  
  # --- 4. Read data with fread (highly efficient) ---
  data_lines <- cif_content$V1[first_data_line_idx:last_data_line_idx]
  atom_data <- fread(
    text = paste(data_lines, collapse = "\n"),
    header = FALSE,
    sep = "auto",
    quote = ""
  )
  
  # --- 5. VECTORIZED parsing of coordinates and errors ---
  # This helper function operates on an entire vector of strings at once.
  parse_vector_with_error <- function(coord_vector) {
    # str_match is vectorized. It returns a matrix of captures.
    # Group 1: full match, Group 2: value, Group 3: error in parens
    matches <- str_match(coord_vector, "([0-9\\.\\-]+)(?:\\(([0-9]+)\\))?")
    
    value_str <- matches[, 2]
    error_str <- matches[, 3]
    
    # Vectorized calculation of scaled error
    decimal_pos <- regexpr("\\.", value_str)
    decimal_places <- ifelse(decimal_pos == -1, 0, nchar(value_str) - decimal_pos)
    
    # as.numeric and arithmetic ops are all vectorized
    scaled_error <- as.numeric(error_str) * 10^(-decimal_places)
    
    return(list(value = as.numeric(value_str), error = scaled_error))
  }
  
  # Apply the vectorized function to each coordinate column
  x_data <- parse_vector_with_error(atom_data[[col_indices["x"]]])
  y_data <- parse_vector_with_error(atom_data[[col_indices["y"]]])
  z_data <- parse_vector_with_error(atom_data[[col_indices["z"]]])
  
  # --- 6. Assemble the final data table (efficient) ---
  wyckoff_multiplicity <- if (!is.na(col_indices["multiplicity"])) {
    as.numeric(atom_data[[col_indices["multiplicity"]]])
  } else {
    rep(NA_real_, nrow(atom_data))
  }
  
  atomic_coordinates <- data.table(
    Label = atom_data[[col_indices["label"]]],
    WychoffMultiplicity = wyckoff_multiplicity,
    x_a = x_data$value,
    y_b = y_data$value,
    z_c = z_data$value,
    x_error = x_data$error,
    y_error = y_data$error,
    z_error = z_data$error
  )
  
  return(atomic_coordinates)
}
```

### Function to extract symmetry operations from CIF content

```{r}
# --- Extract Symmetry Operations ---
# Description: Parses the symmetry operation definitions (e.g., 'x, -y, z+1/2')
#              from the CIF content.
# Parameters:
#   - cif_content: A data.table containing the lines of a CIF file.
# Returns:
#   - A data.table with columns 'x', 'y', and 'z' containing the string
#     representation of each symmetry operation component.
extract_symmetry_operations <- function(cif_content) {
  # --- 1. Find the start of the symmetry loop (logic is sound) ---
  symop_tag <- "_space_group_symop_operation_xyz"
  first_header_line_idx <- grep(symop_tag, cif_content$V1)[1]
  if (is.na(first_header_line_idx)) {
    symop_tag <- "_symmetry_equiv_pos_as_xyz"
    first_header_line_idx <- grep(symop_tag, cif_content$V1)[1]
    if (is.na(first_header_line_idx)) return(NULL)
  }
  loop_start_line_idx <- max(grep("^loop_", cif_content$V1[1:first_header_line_idx]))
  if (is.infinite(loop_start_line_idx)) return(NULL)

  # --- 2. Find the range of data lines (logic is sound) ---
  # Headers start on the line after loop_
  line_indices <- (loop_start_line_idx + 1):nrow(cif_content)
  first_data_line_idx <- 0
  for (i in line_indices) {
    if (!startsWith(cif_content$V1[i], "_")) {
      first_data_line_idx <- i
      break
    }
  }
  if (first_data_line_idx == 0) return(NULL) # No data lines found

  end_candidates <- c(
    grep("^loop_|^_|^#", cif_content$V1[first_data_line_idx:nrow(cif_content)]),
    grep("^\\s*$", cif_content$V1[first_data_line_idx:nrow(cif_content)])
  )
  last_data_line_idx <- if (length(end_candidates) > 0) {
    first_data_line_idx + min(end_candidates) - 2
  } else {
    nrow(cif_content)
  }
  if (first_data_line_idx > last_data_line_idx) return(NULL)

  # --- 3. Extract and parse raw data lines (THE CORRECTED PART) ---
  # Get the raw lines as a character vector. DO NOT use fread here.
  data_lines <- cif_content$V1[first_data_line_idx:last_data_line_idx]

  # Clean the lines:
  # a) Remove optional leading number and whitespace (e.g., '1 ' from CIF 2)
  # b) Remove optional surrounding quotes (single or double)
  # c) Trim whitespace from the ends
  cleaned_lines <- trimws(gsub("^'|^\"|'$|\"$", "", trimws(sub("^[0-9]+\\s+", "", data_lines))))

  # Split the cleaned 'x,y,z' string by the comma. This is the reliable delimiter.
  symmetry_matrix <- str_split_fixed(cleaned_lines, ",", n = 3)

  # Create the final data.table, trimming whitespace from each component
  symmetry_dt <- data.table(
    x = trimws(symmetry_matrix[, 1]),
    y = trimws(symmetry_matrix[, 2]),
    z = trimws(symmetry_matrix[, 3])
  )
  
  return(symmetry_dt)
}
```

### Function to apply symmetry operations to atomic coordinates

```{r}
# --- Apply Symmetry Operations ---
# Description: Generates all symmetry-equivalent atomic positions within the unit cell
#              by applying the list of symmetry operations to the initial set of
#              asymmetric atoms.
# Parameters:
#   - atomic_coordinates: A data.table of asymmetric atoms from `extract_atomic_coordinates`.
#   - symmetry_operations: A data.table of operations from `extract_symmetry_operations`.
# Returns:
#   - A data.table containing all unique atomic positions in the unit cell, with
#     updated labels to ensure uniqueness.
apply_symmetry_operations <- function(atomic_coordinates, symmetry_operations) {
  # Helper function to evaluate a single operation string (e.g., '-y+1/2')
  apply_operation <- function(operation, x, y, z) {
    operation <- gsub("x", sprintf("(%f)", x), operation)
    operation <- gsub("y", sprintf("(%f)", y), operation)
    operation <- gsub("z", sprintf("(%f)", z), operation)
    eval(parse(text = operation))
  }
  
  # Function to expand a single atom to all its symmetric equivalents
  expand_coordinates <- function(row) {
    x <- row$x_a
    y <- row$y_b
    z <- row$z_c
    
    new_coords <- rbindlist(lapply(1:nrow(symmetry_operations), function(i) {
      new_x <- apply_operation(symmetry_operations[i, x], x, y, z)
      new_y <- apply_operation(symmetry_operations[i, y], x, y, z)
      new_z <- apply_operation(symmetry_operations[i, z], x, y, z)
      
      # Fold coordinates back into the primary unit cell [0, 1)
      data.table(
        Label = paste(row$Label, i, sep = "_"),
        # Apply unique label
        x_a = new_x %% 1,
        y_b = new_y %% 1,
        z_c = new_z %% 1
      )
    }))
    return(new_coords)
  }
  
  # Apply symmetry operations to all asymmetric atoms
  transformed_coords <- rbindlist(lapply(1:nrow(atomic_coordinates), function(i) {
    expand_coordinates(atomic_coordinates[i])
  }))
  
  # Remove duplicate positions that may arise from the operations
  transformed_coords <- transformed_coords %>%
    distinct(x_a, y_b, z_c, .keep_all = TRUE)
  
  return(transformed_coords)
}
```

### Function to expand transformed coordinates in all neighboring unit cells

```{r}
# --- Expand to Neighboring Unit Cells ---
# Description: Takes a set of atomic coordinates within a single unit cell and
#              replicates them into a 3x3x3 supercell grid (27 total cells,
#              including the original).
# Parameters:
#   - transformed_coords: A data.table of atom positions within one unit cell.
# Returns:
#   - A data.table containing all atomic positions in the expanded supercell.
expand_transformed_coords <- function(transformed_coords) {
  n_cells <- 1 # Expand by 1 cell in each direction (+/- 1)
  
  # Generate a grid of translation vectors for each neighboring cell
  cell_indices <- as.data.table(expand.grid(
    x = -n_cells:n_cells,
    y = -n_cells:n_cells,
    z = -n_cells:n_cells
  ))
  
  # Apply each translation vector to the set of atoms
  expanded_coords <- rbindlist(lapply(1:nrow(cell_indices), function(i) {
    cell_shift <- cell_indices[i]
    new_coords <- transformed_coords[, .(
      Label = paste(
        Label,
        paste(cell_shift$x, cell_shift$y, cell_shift$z, sep = "_"),
        sep = "_"
      ),
      x_a = x_a + cell_shift$x,
      y_b = y_b + cell_shift$y,
      z_c = z_c + cell_shift$z
    )]
    return(new_coords)
  }))
  
  # Remove duplicate atoms that might be generated at the boundaries
  expanded_coords <- expanded_coords %>%
    distinct(x_a, y_b, z_c, .keep_all = TRUE)
  
  return(expanded_coords)
}
```

### Function to calculate distances between atoms using real-space metric tensor and vectorization

```{r}
# --- Calculate Interatomic Distances ---
# Description: Computes the distances between a central set of atoms (asymmetric set)
#              and a larger, expanded set of atoms (supercell). Uses the metric
#              tensor to correctly handle non-orthogonal (e.g., triclinic) unit cells.
# Parameters:
#   - atomic_coordinates: The primary set of atoms (typically the asymmetric atoms).
#   - expanded_coords: The set of atoms to calculate distances to (typically the supercell).
#   - unit_cell_metrics: A data.table with cell parameters a, b, c, alpha, beta, gamma.
# Returns:
#   - A data.table of all non-zero distances, with columns for Atom1, Atom2, and Distance.
calculate_distances <- function(atomic_coordinates,
                                expanded_coords,
                                unit_cell_metrics) {
  # Extract and convert unit cell parameters
  a <- unit_cell_metrics$`_cell_length_a`
  b <- unit_cell_metrics$`_cell_length_b`
  c <- unit_cell_metrics$`_cell_length_c`
  alpha <- unit_cell_metrics$`_cell_angle_alpha` * pi / 180
  beta <- unit_cell_metrics$`_cell_angle_beta` * pi / 180
  gamma <- unit_cell_metrics$`_cell_angle_gamma` * pi / 180
  
  # Prepare coordinates for vectorized calculation
  coords_atomic <- as.matrix(atomic_coordinates[, .(x_a, y_b, z_c)])
  coords_expanded <- as.matrix(expanded_coords[, .(x_a, y_b, z_c)])
  labels_atomic <- atomic_coordinates$Label
  labels_expanded <- expanded_coords$Label
  
  # Calculate pairwise differences in fractional coordinates
  delta_x <- outer(coords_atomic[, 1], coords_expanded[, 1], "-")
  delta_y <- outer(coords_atomic[, 2], coords_expanded[, 2], "-")
  delta_z <- outer(coords_atomic[, 3], coords_expanded[, 3], "-")
  
  cos_alpha <- cos(alpha)
  cos_beta <- cos(beta)
  cos_gamma <- cos(gamma)
  
  # Calculate squared distance using the general (triclinic) distance formula
  r2 <- (a^2 * delta_x^2) + (b^2 * delta_y^2) + (c^2 * delta_z^2) +
    (2 * b * c * cos_alpha * delta_y * delta_z) +
    (2 * c * a * cos_beta * delta_z * delta_x) +
    (2 * a * b * cos_gamma * delta_x * delta_y)
  
  r <- sqrt(r2)
  
  # Create a data table of the results
  atom_pairs <- expand.grid(Atom1 = labels_atomic,
                            Atom2 = labels_expanded,
                            KEEP.OUT.ATTRS = TRUE)
  distances <- data.table(
    Atom1 = atom_pairs$Atom1,
    Atom2 = atom_pairs$Atom2,
    Distance = as.vector(r),
    DeltaX = as.vector(delta_x),
    # Keep for later use if needed
    DeltaY = as.vector(delta_y),
    DeltaZ = as.vector(delta_z)
  )
  
  # Filter out self-distances (zero)
  distances <- distances[Distance > 1e-6]
  
  return(distances)
}
```

### Function to apply Minimum Distance Method

```{r}
# --- Minimum Distance Method for Bonding ---
# Description: Identifies bonded atoms by finding the nearest neighbor distance (d_min)
#              for each central atom and defining a cutoff distance (d_cut) as
#              d_cut = (1 + delta) * d_min. All atoms within d_cut are considered bonded.
# Parameters:
#   - distances: A data.table of interatomic distances from `calculate_distances`.
#   - delta: The relative tolerance parameter (default 0.1 or 10%).
# Returns:
#   - A data.table of bonded pairs with columns Atom1, Atom2, Distance, d_cut, and d_min.
minimum_distance <- function(distances, delta = 0.1) {
  # For each central atom (Atom1), find its minimum distance to any other atom
  dmin <- distances[, .(dmin = min(Distance)), by = .(Atom1)]
  
  # Calculate the cutoff distance based on dmin and the tolerance delta
  dmin[, dcut := (1 + delta) * dmin]
  
  # Join the cutoff back to the original distances and filter for bonded pairs
  # Keep the Delta columns for use in error propagation.
  bonded_pairs <- distances[dmin, on = .(Atom1), allow.cartesian = TRUE][
    Distance <= dcut, 
    .(Atom1, Atom2, Distance, DeltaX, DeltaY, DeltaZ, dcut, dmin)
  ]
  
  return(bonded_pairs)
}
```

### Function to apply Brunner's Largest Reciprocal Gap Method (In Progress)

```{r}
# --- Brunner's Largest Reciprocal Gap Method (In Progress) ---
# Description: An alternative bonding detection method. Not currently used.
brunner <- function(distances, delta = 0.0001) {
  # Initialize an empty list to store the bonds
  bonds <- list()

  # Iterate over each unique central atom in the distances table
  unique_atoms <- unique(distances$Atom1)
  for (atom in unique_atoms) {
    # Filter distances for the current Atom1 and order by distance
    atom_distances <- distances[Atom1 == atom][order(Distance)]

    # Initialize the largest reciprocal gap and the corresponding index
    largest_gap <- -Inf
    j_max <- NA

    # Calculate the largest reciprocal gap
    for (j in 1:(nrow(atom_distances) - 1)) {
      reciprocal_gap <- 1 / atom_distances$Distance[j] - 1 / atom_distances$Distance[j + 1]
      if (reciprocal_gap > largest_gap) {
        largest_gap <- reciprocal_gap
        j_max <- j
      }
    }

    # Determine the distance cut-off
    d_cut <- atom_distances$Distance[j_max] + delta

    # Select the bonds within the distance cut-off
    bonded_atoms <- atom_distances[Distance <= d_cut]

    # Store the bonds for the current atom
    bonds[[atom]] <- bonded_atoms
  }

  # Combine all bonds into a single data.table
  bonds <- rbindlist(bonds, fill = TRUE)
  return(bonds)
}
```

### Function to apply Hoppe's Method of Effective Coordination Numbers (In Progress)

```{r}
# --- Hoppe's Method of Effective Coordination Numbers (In Progress) ---
# Description: An alternative bonding detection method. Not currently used.
hoppe <- function(distances, delta = 0.5, tolerance = 0.001) {
  # Initialize an empty list to store the bonded pairs
  bonded_pairs <- list()

  # Iterate over each unique Atom1 in the distances table
  unique_atoms <- unique(distances$Atom1)
  for (atom in unique_atoms) {
    # Filter distances for the current Atom1
    atom_distances <- distances[Atom1 == atom]

    # Step 1: Calculate dmin for the current atom
    dmin <- min(atom_distances$Distance)

    # Step 2: Calculate initial davg (0davg)
    davg <- sum(atom_distances$Distance * exp(1 - (atom_distances$Distance / dmin)^6)) /
            sum(exp(1 - (atom_distances$Distance / dmin)^6))

    # Step 3: Iteratively calculate ndavg until convergence
    ndavg <- davg
    while (TRUE) {
      prev_davg <- davg
      davg <- sum(atom_distances$Distance * exp(1 - (atom_distances$Distance / prev_davg)^6)) /
              sum(exp(1 - (atom_distances$Distance / prev_davg)^6))
      if (abs(davg - prev_davg) <= tolerance) break
    }

    # Step 4: Determine bonded pairs and their bond strength based on the tolerance parameter Î´
    atom_distances[, BondStrength := exp(1 - (Distance / davg)^6)]
    bonded <- atom_distances[BondStrength >= delta, .(Atom1, Atom2, Distance)]
    bonded_pairs[[atom]] <- bonded
  }

  # Combine all bonded pairs into a single data.table
  bonded_pairs <- rbindlist(bonded_pairs, fill = TRUE)
  return(bonded_pairs)
}
```

#### Function to calculate the number of nearest neighbors for each atom

```{r}
# --- Calculate Neighbor Counts ---
# Description: Counts the number of nearest neighbors for each central atom based on
#              a table of bonded pairs.
# Parameters:
#   - bonded_pairs_table: A data.table of bonded pairs, e.g., from `minimum_distance`.
# Returns:
#   - A data.table with columns 'Atom' and 'NeighborCount'.
calculate_neighbor_counts <- function(bonded_pairs_table) {
  if (is.null(bonded_pairs_table) || nrow(bonded_pairs_table) == 0) {
    return(data.table(Atom = character(), NeighborCount = integer()))
  }
  
  # Group by the central atom (Atom1) and count the number of rows (.N)
  neighbor_counts <- bonded_pairs_table[, .(NeighborCount = .N), by = .(Atom1)]
  
  setnames(neighbor_counts, "Atom1", "Atom")
  
  return(neighbor_counts)
}
```

### Calculate Bond Angles

```{r}
# --- Calculate Bond Angles ---
# Description: Calculates all bond angles centered on each atom, formed by pairs
#              of its bonded neighbors. Uses the metric tensor for accuracy in
#              any crystal system.
# Parameters:
#   - bonded_pairs: Data.table of bonded atoms.
#   - atomic_coordinates: Data.table of asymmetric atom coordinates.
#   - expanded_coords: Data.table of supercell atom coordinates.
#   - unit_cell_metrics: Data.table with unit cell parameters.
# Returns:
#   - A data.table of all unique bond angles with columns CentralAtom, Neighbor1,
#     Neighbor2, and Angle (in degrees).
calculate_angles <- function(bonded_pairs,
                             atomic_coordinates,
                             expanded_coords,
                             unit_cell_metrics) {
  # Extract and convert unit cell parameters
  a <- unit_cell_metrics$`_cell_length_a`
  b <- unit_cell_metrics$`_cell_length_b`
  c <- unit_cell_metrics$`_cell_length_c`
  alpha_rad <- unit_cell_metrics$`_cell_angle_alpha` * pi / 180
  beta_rad <- unit_cell_metrics$`_cell_angle_beta` * pi / 180
  gamma_rad <- unit_cell_metrics$`_cell_angle_gamma` * pi / 180
  
  cos_alpha <- cos(alpha_rad)
  cos_beta <- cos(beta_rad)
  cos_gamma <- cos(gamma_rad)
  
  # Combine all known coordinates for easy lookup
  all_coords <- rbind(atomic_coordinates[, .(Label, x_a, y_b, z_c)], expanded_coords[, .(Label, x_a, y_b, z_c)], fill = TRUE)
  all_coords <- unique(all_coords, by = "Label")
  setkey(all_coords, Label)
  
  # Helper function to calculate a single angle using the metric tensor
  calculate_angle_metric <- function(atom1_label, atom2_label, atom3_label) {
    coord1 <- all_coords[atom1_label, .(x_a, y_b, z_c)]
    coord2 <- all_coords[atom2_label, .(x_a, y_b, z_c)]
    coord3 <- all_coords[atom3_label, .(x_a, y_b, z_c)]
    
    if (anyNA(coord1) ||
        anyNA(coord2) || anyNA(coord3))
      return(NA_real_)
    
    # Calculate fractional difference vectors v1=(atom2-atom1), v2=(atom3-atom1)
    v1_frac <- as.numeric(coord2 - coord1)
    v2_frac <- as.numeric(coord3 - coord1)
    xf1 <- v1_frac[1]
    yf1 <- v1_frac[2]
    zf1 <- v1_frac[3]
    xf2 <- v2_frac[1]
    yf2 <- v2_frac[2]
    zf2 <- v2_frac[3]
    
    # Calculate dot product v1 . v2 using metric tensor
    dot_product <- (
      xf1 * xf2 * a^2 + yf1 * yf2 * b^2 + zf1 * zf2 * c^2 +
        (xf1 * yf2 + yf1 * xf2) * a * b * cos_gamma +
        (xf1 * zf2 + zf1 * xf2) * a * c * cos_beta +
        (yf1 * zf2 + zf1 * yf2) * b * c * cos_alpha
    )
    
    # Calculate squared magnitudes of v1 and v2
    mag_sq1 <- (
      xf1^2 * a^2 + yf1^2 * b^2 + zf1^2 * c^2 + 2 * xf1 * yf1 * a * b * cos_gamma + 2 *
        xf1 * zf1 * a * c * cos_beta + 2 * yf1 * zf1 * b * c * cos_alpha
    )
    mag_sq2 <- (
      xf2^2 * a^2 + yf2^2 * b^2 + zf2^2 * c^2 + 2 * xf2 * yf2 * a * b * cos_gamma + 2 *
        xf2 * zf2 * a * c * cos_beta + 2 * yf2 * zf2 * b * c * cos_alpha
    )
    
    if (mag_sq1 <= 1e-10 || mag_sq2 <= 1e-10)
      return(NA_real_)
    
    mag1 <- sqrt(mag_sq1)
    mag2 <- sqrt(mag_sq2)
    cos_theta <- min(max(dot_product / (mag1 * mag2), -1.0), 1.0)
    return(acos(cos_theta) * 180 / pi)
  }
  
  angle_list <- list()
  unique_central_atoms <- unique(bonded_pairs$Atom1)
  
  for (central_atom in unique_central_atoms) {
    bonded_neighbors <- bonded_pairs[Atom1 == central_atom, Atom2]
    if (length(bonded_neighbors) >= 2) {
      # Generate unique combinations of two neighbors to form an angle
      neighbor_combinations <- combn(bonded_neighbors, 2, simplify = FALSE)
      for (pair in neighbor_combinations) {
        angle <- calculate_angle_metric(central_atom, pair[1], pair[2])
        if (!is.na(angle)) {
          angle_list[[length(angle_list) + 1]] <- data.table(
            CentralAtom = central_atom,
            Neighbor1 = pair[1],
            Neighbor2 = pair[2],
            Angle = angle
          )
        }
      }
    }
  }
  
  if (length(angle_list) > 0) {
    angle_results <- rbindlist(angle_list)
    angle_results <- angle_results[order(CentralAtom, Neighbor1, Neighbor2)]
  } else {
    angle_results <- data.table(
      CentralAtom = character(),
      Neighbor1 = character(),
      Neighbor2 = character(),
      Angle = numeric()
    )
  }
  
  return(angle_results)
}
```

### Distance Error Propogation

```{r}
# --- Propagate Distance Error ---
# Description: Calculates the standard uncertainty for each interatomic distance by
#              propagating the errors from the cell parameters and atomic coordinates.
#              Assumes uncorrelated parameters.
# Parameters:
#   - bonded_pairs: Data.table of bonded atoms with their distances.
#   - atomic_coordinates: Data.table with fractional coordinates and errors.
#   - expanded_coords: Data.table of supercell atom coordinates.
#   - unit_cell_metrics: Data.table with unit cell parameters and errors.
# Returns:
#   - The input `bonded_pairs` data.table with a new 'DistanceError' column.
propagate_distance_error <- function(bonded_pairs,
                                     atomic_coordinates,
                                     unit_cell_metrics) {
  if (is.null(bonded_pairs) || nrow(bonded_pairs) == 0) {
    return(bonded_pairs[, DistanceError := NA_real_])
  }

  # --- 1. Setup: Extract parameters and their standard deviations (sigmas) ---
  a <- unit_cell_metrics$`_cell_length_a`
  s_a <- unit_cell_metrics$`_cell_length_a_error`
  b <- unit_cell_metrics$`_cell_length_b`
  s_b <- unit_cell_metrics$`_cell_length_b_error`
  c <- unit_cell_metrics$`_cell_length_c`
  s_c <- unit_cell_metrics$`_cell_length_c_error`

  alpha_rad <- unit_cell_metrics$`_cell_angle_alpha` * pi / 180
  s_alpha_rad <- unit_cell_metrics$`_cell_angle_alpha_error` * pi / 180
  beta_rad <- unit_cell_metrics$`_cell_angle_beta` * pi / 180
  s_beta_rad <- unit_cell_metrics$`_cell_angle_beta_error` * pi / 180
  gamma_rad <- unit_cell_metrics$`_cell_angle_gamma` * pi / 180
  s_gamma_rad <- unit_cell_metrics$`_cell_angle_gamma_error` * pi / 180

  # Pre-calculate trigonometric values and handle NA sigmas
  cos_a <- cos(alpha_rad)
  sin_a <- sin(alpha_rad)
  cos_b <- cos(beta_rad)
  sin_b <- sin(beta_rad)
  cos_g <- cos(gamma_rad)
  sin_g <- sin(gamma_rad)

  s_a <- ifelse(is.na(s_a), 0, s_a)
  s_b <- ifelse(is.na(s_b), 0, s_b)
  s_c <- ifelse(is.na(s_c), 0, s_c)
  s_alpha_rad <- ifelse(is.na(s_alpha_rad), 0, s_alpha_rad)
  s_beta_rad <- ifelse(is.na(s_beta_rad), 0, s_beta_rad)
  s_gamma_rad <- ifelse(is.na(s_gamma_rad), 0, s_gamma_rad)

  # --- 2. Data Preparation: Create a working data.table with all necessary values ---
  work_dt <- copy(bonded_pairs)
  setnames(work_dt, c("DeltaX", "DeltaY", "DeltaZ"), c("dx", "dy", "dz"))

  atom_errors <- atomic_coordinates[, .(Label,
                                        s_xf = x_error,
                                        s_yf = y_error,
                                        s_zf = z_error)]

  # Join errors for Atom1 and Atom2
  work_dt <- merge(
    work_dt,
    atom_errors,
    by.x = "Atom1",
    by.y = "Label",
    all.x = TRUE
  )
  setnames(work_dt,
           c("s_xf", "s_yf", "s_zf"),
           c("s_xf1", "s_yf1", "s_zf1"))
  work_dt[, Original_Atom2 := sub("_.*", "", Atom2)]
  work_dt <- merge(
    work_dt,
    atom_errors,
    by.x = "Original_Atom2",
    by.y = "Label",
    all.x = TRUE
  )
  setnames(work_dt,
           c("s_xf", "s_yf", "s_zf"),
           c("s_xf2", "s_yf2", "s_zf2"))
  work_dt[, Original_Atom2 := NULL]

  # Replace NA coordinate sigmas with 0
  coord_err_cols <- c("s_xf1", "s_yf1", "s_zf1", "s_xf2", "s_yf2", "s_zf2")
  for (col in coord_err_cols)
    set(work_dt, which(is.na(work_dt[[col]])), col, 0)

  # --- 3. Vectorized Error Propagation Calculation ---
  work_dt[, term_common := 1 / (2 * Distance)]

  # Derivatives of cell parameters
  work_dt[, pd_a     := term_common * (2 * a * dx^2 + 2 * b * dx * dy *
                                         cos_g + 2 * c * dx * dz * cos_b)]
  work_dt[, pd_b     := term_common * (2 * b * dy^2 + 2 * a * dx * dy *
                                         cos_g + 2 * c * dy * dz * cos_a)]
  work_dt[, pd_c     := term_common * (2 * c * dz^2 + 2 * a * dx * dz *
                                         cos_b + 2 * b * dy * dz * cos_a)]
  work_dt[, pd_alpha := term_common * (-2 * b * c * dy * dz * sin_a)]
  work_dt[, pd_beta  := term_common * (-2 * a * c * dx * dz * sin_b)]
  work_dt[, pd_gamma := term_common * (-2 * a * b * dx * dy * sin_g)]

  # Derivatives of fractional coordinates
  work_dt[, pd_xf1 := term_common * (2 * a^2 * dx + 2 * a * b * dy * cos_g + 2 *
                                       a * c * dz * cos_b)]
  work_dt[, pd_yf1 := term_common * (2 * b^2 * dy + 2 * a * b * dx * cos_g + 2 *
                                       b * c * dz * cos_a)]
  work_dt[, pd_zf1 := term_common * (2 * c^2 * dz + 2 * a * c * dx * cos_b + 2 *
                                       b * c * dy * cos_a)]
  work_dt[, `:=`(
    pd_xf2 = -pd_xf1,
    pd_yf2 = -pd_yf1,
    pd_zf2 = -pd_zf1
  )]

  # Sum of squares of (partial_derivative * sigma)
  work_dt[, variance := (pd_a * s_a)^2 + (pd_b * s_b)^2 + (pd_c * s_c)^2 +
            (pd_alpha * s_alpha_rad)^2 + (pd_beta * s_beta_rad)^2 + (pd_gamma *
                                                                       s_gamma_rad)^2 +
            (pd_xf1 * s_xf1)^2 + (pd_yf1 * s_yf1)^2 + (pd_zf1 *
                                                         s_zf1)^2 +
            (pd_xf2 * s_xf2)^2 + (pd_yf2 * s_yf2)^2 + (pd_zf2 *
                                                         s_zf2)^2]

  work_dt[, DistanceError := sqrt(variance)]

  # Merge the final error back into the original table
  result <- merge(
    bonded_pairs,
    work_dt[, .(Atom1, Atom2, Distance, DistanceError)],
    by = c("Atom1", "Atom2", "Distance"),
    all.x = TRUE
  )
  return(result)
}
```

### Angle Error Propogation

```{r}
# --- Propagate Angle Error ---
# Description: Calculates the standard uncertainty for each bond angle using a fully
#              vectorized approach with data.table. It avoids all R-level loops.
#              1. Propagates errors from cell/fractional params to Cartesian coordinates.
#              2. Propagates errors from Cartesian coordinates to the final angle.
# Parameters:
#   - bond_angles: Data.table of calculated bond angles.
#   - atomic_coordinates: Data.table with fractional coordinates and errors.
#   - expanded_coords: Data.table of supercell atom coordinates.
#   - unit_cell_metrics: Data.table with unit cell parameters and errors.
# Returns:
#   - The input `bond_angles` data.table with a new 'AngleError' column.
propagate_angle_error <- function(bond_angles,
                                  atomic_coordinates,
                                  expanded_coords,
                                  unit_cell_metrics) {
  if (is.null(bond_angles) || nrow(bond_angles) == 0) {
    return(bond_angles[, AngleError := NA_real_])
  }
  
  # --- Step 1: Setup and Parameter Extraction (Scalar values) ---
  a <- unit_cell_metrics$`_cell_length_a`
  b <- unit_cell_metrics$`_cell_length_b`
  c <- unit_cell_metrics$`_cell_length_c`
  s_a <- ifelse(is.na(unit_cell_metrics$`_cell_length_a_error`), 0, unit_cell_metrics$`_cell_length_a_error`)
  s_b <- ifelse(is.na(unit_cell_metrics$`_cell_length_b_error`), 0, unit_cell_metrics$`_cell_length_b_error`)
  s_c <- ifelse(is.na(unit_cell_metrics$`_cell_length_c_error`), 0, unit_cell_metrics$`_cell_length_c_error`)
  
  alpha_rad <- unit_cell_metrics$`_cell_angle_alpha` * pi / 180
  beta_rad <- unit_cell_metrics$`_cell_angle_beta` * pi / 180
  gamma_rad <- unit_cell_metrics$`_cell_angle_gamma` * pi / 180
  s_alpha_rad <- ifelse(is.na(unit_cell_metrics$`_cell_angle_alpha_error`), 0, unit_cell_metrics$`_cell_angle_alpha_error` * pi / 180)
  s_beta_rad <- ifelse(is.na(unit_cell_metrics$`_cell_angle_beta_error`), 0, unit_cell_metrics$`_cell_angle_beta_error` * pi / 180)
  s_gamma_rad <- ifelse(is.na(unit_cell_metrics$`_cell_angle_gamma_error`), 0, unit_cell_metrics$`_cell_angle_gamma_error` * pi / 180)
  
  cos_a <- cos(alpha_rad); sin_a <- sin(alpha_rad)
  cos_b <- cos(beta_rad);  sin_b <- sin(beta_rad)
  cos_g <- cos(gamma_rad);  sin_g <- sin(gamma_rad)
  
  v_sq <- 1.0 - cos_a^2 - cos_b^2 - cos_g^2 + 2 * cos_a * cos_b * cos_g
  v <- sqrt(v_sq)

  # --- Step 2: Vectorized Calculation of Cartesian Errors for Asymmetric Atoms ---
  # These errors are inherited by all symmetrically-equivalent atoms.
  cart_errors <- copy(atomic_coordinates)
  for (col in c("x_error", "y_error", "z_error")) set(cart_errors, which(is.na(cart_errors[[col]])), col, 0)
  
  # Calculate all partial derivatives as new columns
  cart_errors[, `:=`(
    p_xc_a = x_a, p_xc_b = y_b * cos_g, p_xc_c = z_c * cos_b,
    p_xc_alpha = 0, p_xc_beta = -c * z_c * sin_b, p_xc_gamma = -b * y_b * sin_g,
    p_xc_xf = a, p_xc_yf = b * cos_g, p_xc_zf = c * cos_b,
    
    p_yc_a = 0, p_yc_b = y_b * sin_g, p_yc_c = z_c * (cos_a - cos_b * cos_g) / sin_g,
    p_yc_alpha = -c * z_c * sin_a / sin_g, p_yc_beta = c * z_c * sin_b * cos_g / sin_g,
    p_yc_gamma = b * y_b * cos_g + c * z_c * (cos_b - cos_a * cos_g) / sin_g^2,
    p_yc_xf = 0, p_yc_yf = b * sin_g, p_yc_zf = c * (cos_a - cos_b * cos_g) / sin_g,
    
    p_zc_a = 0, p_zc_b = 0, p_zc_c = z_c * v / sin_g,
    p_zc_alpha = c * z_c * (cos_b * cos_g - cos_a) / (sin_g * v),
    p_zc_beta = c * z_c * (cos_a * cos_g - cos_b) / (sin_g * v),
    p_zc_gamma = -c * z_c * (v_sq * cos_g + sin_g^2 * (cos_a * cos_b - cos_g)) / (sin_g^2 * v),
    p_zc_xf = 0, p_zc_yf = 0, p_zc_zf = c * v / sin_g
  )]
  
  # Calculate squared uncertainty (variance) for each Cartesian coordinate
  cart_errors[, s_xc_sq := (p_xc_a*s_a)^2 + (p_xc_b*s_b)^2 + (p_xc_c*s_c)^2 + (p_xc_alpha*s_alpha_rad)^2 + (p_xc_beta*s_beta_rad)^2 + (p_xc_gamma*s_gamma_rad)^2 + (p_xc_xf*x_error)^2 + (p_xc_yf*y_error)^2 + (p_xc_zf*z_error)^2]
  cart_errors[, s_yc_sq := (p_yc_a*s_a)^2 + (p_yc_b*s_b)^2 + (p_yc_c*s_c)^2 + (p_yc_alpha*s_alpha_rad)^2 + (p_yc_beta*s_beta_rad)^2 + (p_yc_gamma*s_gamma_rad)^2 + (p_yc_xf*x_error)^2 + (p_yc_yf*y_error)^2 + (p_yc_zf*z_error)^2]
  cart_errors[, s_zc_sq := (p_zc_a*s_a)^2 + (p_zc_b*s_b)^2 + (p_zc_c*s_c)^2 + (p_zc_alpha*s_alpha_rad)^2 + (p_zc_beta*s_beta_rad)^2 + (p_zc_gamma*s_gamma_rad)^2 + (p_zc_xf*x_error)^2 + (p_zc_yf*y_error)^2 + (p_zc_zf*z_error)^2]

  # --- Step 3: Data Assembly and Vectorized Propagation ---
  # Create lookup tables for coordinates and errors
  all_frac_coords <- unique(rbind(atomic_coordinates[, .(Label, x_a, y_b, z_c)], expanded_coords), by="Label")
  all_cart_coords <- all_frac_coords[, `:=`(
    xc = a * x_a + b * y_b * cos_g + c * z_c * cos_b,
    yc = b * y_b * sin_g + c * z_c * (cos_a - cos_b * cos_g) / sin_g,
    zc = c * z_c * v / sin_g
  )][, .(Label, xc, yc, zc)]
  setkey(all_cart_coords, Label)
  
  error_subset <- cart_errors[, .(Label, s_xc_sq, s_yc_sq, s_zc_sq)]
  setkey(error_subset, Label)
  
  # Prepare the main working table
  work_dt <- copy(bond_angles)
  
  # Join coordinates and errors for all 3 atoms in one pass using chained joins
  work_dt[all_cart_coords, on = .(CentralAtom = Label), `:=`(xc1=i.xc, yc1=i.yc, zc1=i.zc)]
  work_dt[all_cart_coords, on = .(Neighbor1 = Label), `:=`(xc2=i.xc, yc2=i.yc, zc2=i.zc)]
  work_dt[all_cart_coords, on = .(Neighbor2 = Label), `:=`(xc3=i.xc, yc3=i.yc, zc3=i.zc)]
  
  work_dt[, Parent_C  := sub("_.*", "", CentralAtom)]
  work_dt[, Parent_N1 := sub("_.*", "", Neighbor1)]
  work_dt[, Parent_N2 := sub("_.*", "", Neighbor2)]
  
  work_dt[error_subset, on = .(Parent_C = Label), `:=`(s_xc1_sq=i.s_xc_sq, s_yc1_sq=i.s_yc_sq, s_zc1_sq=i.s_zc_sq)]
  work_dt[error_subset, on = .(Parent_N1 = Label), `:=`(s_xc2_sq=i.s_xc_sq, s_yc2_sq=i.s_yc_sq, s_zc2_sq=i.s_zc_sq)]
  work_dt[error_subset, on = .(Parent_N2 = Label), `:=`(s_xc3_sq=i.s_xc_sq, s_yc3_sq=i.s_yc_sq, s_zc3_sq=i.s_zc_sq)]

  # Vectorized calculation of angle error
  work_dt[, `:=`(
    a_vx = xc2 - xc1, a_vy = yc2 - yc1, a_vz = zc2 - zc1,
    b_vx = xc3 - xc1, b_vy = yc3 - yc1, b_vz = zc3 - zc1
  )]
  
  work_dt[, `:=`(mag_a = sqrt(a_vx^2 + a_vy^2 + a_vz^2), mag_b = sqrt(b_vx^2 + b_vy^2 + b_vz^2))]
  work_dt <- work_dt[mag_a > 1e-9 & mag_b > 1e-9] # Filter out zero-length vectors
  
  work_dt[, C_val := (a_vx*b_vx + a_vy*b_vy + a_vz*b_vz) / (mag_a * mag_b)]
  work_dt[, C_val := pmin(pmax(C_val, -1.0), 1.0)] # Clamp to valid range for acos
  
  # Partials of C w.r.t cartesian coordinates (via chain rule)
  work_dt[, `:=`(
    p_C_xc1 = -(((b_vx/mag_b - C_val*a_vx/mag_a)/mag_a) + ((a_vx/mag_a - C_val*b_vx/mag_b)/mag_b)),
    p_C_yc1 = -(((b_vy/mag_b - C_val*a_vy/mag_a)/mag_a) + ((a_vy/mag_a - C_val*b_vy/mag_b)/mag_b)),
    p_C_zc1 = -(((b_vz/mag_b - C_val*a_vz/mag_a)/mag_a) + ((a_vz/mag_a - C_val*b_vz/mag_b)/mag_b)),
    p_C_xc2 = (b_vx/mag_b - C_val*a_vx/mag_a)/mag_a,
    p_C_yc2 = (b_vy/mag_b - C_val*a_vy/mag_a)/mag_a,
    p_C_zc2 = (b_vz/mag_b - C_val*a_vz/mag_a)/mag_a,
    p_C_xc3 = (a_vx/mag_a - C_val*b_vx/mag_b)/mag_b,
    p_C_yc3 = (a_vy/mag_a - C_val*b_vy/mag_b)/mag_b,
    p_C_zc3 = (a_vz/mag_a - C_val*b_vz/mag_b)/mag_b
  )]

  # Final error calculation
  work_dt[, s_C_sq := (p_C_xc1^2 * s_xc1_sq) + (p_C_yc1^2 * s_yc1_sq) + (p_C_zc1^2 * s_zc1_sq) +
                      (p_C_xc2^2 * s_xc2_sq) + (p_C_yc2^2 * s_yc2_sq) + (p_C_zc2^2 * s_zc2_sq) +
                      (p_C_xc3^2 * s_xc3_sq) + (p_C_yc3^2 * s_yc3_sq) + (p_C_zc3^2 * s_zc3_sq)]
  
  # Handle case where C_val is exactly 1 or -1 to avoid division by zero
  work_dt[C_val^2 >= 1.0, s_theta_sq := 0]
  work_dt[C_val^2 < 1.0, s_theta_sq := s_C_sq / (1 - C_val^2)]
  
  work_dt[, AngleError := sqrt(pmax(0, s_theta_sq)) * 180 / pi]

  # Merge result back into original table
  result <- merge(bond_angles, work_dt[, .(CentralAtom, Neighbor1, Neighbor2, AngleError)], 
                  by=c("CentralAtom", "Neighbor1", "Neighbor2"), all.x=TRUE)
  
  return(result)
}
```

### Final Processing

```{r}
# --- Main Processing Loop ---
# Description: This loop iterates through each CIF file, applies the sequence of
#              extraction and calculation functions, and compiles the final results
#              for each crystal structure into a master data.table.

# Initialize an empty data table to store the results
main_table <- data.table()

# Iterate over each CIF content
for (cif in cif_tab) {
  # 1. Extract basic metadata and parameters
  database_code <- extract_database_code(cif)
  chemical_formula <- extract_chemical_formula(cif)
  structure_type <- extract_structure_type(cif)
  space_group_name <- extract_space_group_name(cif)
  space_group_number <- extract_space_group_number(cif)
  unit_cell_metrics <- extract_unit_cell_metrics(cif)
  atomic_coordinates <- extract_atomic_coordinates(cif)
  
  # 2. Generate the full crystal structure
  symmetry_operations <- extract_symmetry_operations(cif)
  transformed_coords <- apply_symmetry_operations(atomic_coordinates, symmetry_operations)
  expanded_coords <- expand_transformed_coords(transformed_coords)
  
  # 3. Calculate geometric properties
  distances <- calculate_distances(atomic_coordinates, expanded_coords, unit_cell_metrics)
  bonded_pairs <- minimum_distance(distances)
  brunner_pairs <- brunner(distances)
  hoppe_pairs <- hoppe(distances)
  neighbor_counts <- calculate_neighbor_counts(bonded_pairs)
  bond_angles <- calculate_angles(bonded_pairs,
                                  atomic_coordinates,
                                  expanded_coords,
                                  unit_cell_metrics)
  
  # 4. Propagate errors for calculated properties
  bonded_pairs <- propagate_distance_error(bonded_pairs,
                                           atomic_coordinates,
                                           unit_cell_metrics)
  # ADD THIS LINE TO CALCULATE ANGLE ERRORS
  bond_angles <- propagate_angle_error(bond_angles,
                                       atomic_coordinates,
                                       expanded_coords,
                                       unit_cell_metrics)
  
  # 5. Compile all results for the current CIF file into the main table
  main_table <- rbindlist(list(
    main_table,
    data.table(
      database_code = database_code,
      chemical_formula = chemical_formula,
      structure_type = structure_type,
      space_group_name = space_group_name,
      space_group_number = space_group_number,
      unit_cell_metrics = list(unit_cell_metrics),
      atomic_coordinates = list(atomic_coordinates),
      symmetry_operations = list(symmetry_operations),
      transformed_coords = list(transformed_coords),
      expanded_coords = list(expanded_coords),
      distances = list(distances),
      bonded_pairs = list(bonded_pairs),
      brunner_pairs = list(brunner_pairs),
      hoppe_pairs = list(hoppe_pairs),
      neighbor_counts = list(neighbor_counts),
      bond_angles = list(bond_angles)
    )
  ), fill = TRUE)
}
```