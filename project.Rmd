---
title: "Project"
author: "Don Ngo"
date: "`r Sys.Date()`"
output: pdf_document
---

# General Objectives

-   Create a private GitHub repository.
-   Extract information from crystallography files.
-   Identify necessary information for cluster analyses.
-   Build functions.
-   Build a package.

# Set the working directory

```{r}
setwd("~/repos/ml-crystals/")
```

# List CIF files

```{r}
cif_list <- Sys.glob(paths = "data/*.cif")
cif_tab <- lapply(cif_list, readLines , warn =  FALSE)
```

# Packages (to be adjusted)

```{r}
library(data.table)
library(stringr)
```

# Bind CIF Files into One Table

```{r}
# List CIF files
cif_list <- Sys.glob(paths = "data/*.cif")
cif_tab <- lapply(cif_list, fread, sep = "\n", header = FALSE)
```

# Extracting Data

```{r}
# Function to extract a specific value based on a pattern from CIF content
extract_value <- function(cif_content, pattern, remove_pattern = TRUE) {
  # Find lines that match the given pattern
  lines <- cif_content[V1 %like% pattern]
  if (nrow(lines) > 0) {
    value <- lines$V1
    if (remove_pattern) {
      value <- gsub(pattern, "", value)
    }
    # Clean the value by removing quotes and trimming whitespace
    value <- gsub("'", "", value)
    value <- trimws(value)
    return(value)
  } else {
    return(NA)
  }
}

extract_ICSD_code <- function (cif_content) {
  extract_value(cif_content, "_database_code_ICSD")
}

# Specific extraction functions for different properties
extract_chemical_formula <- function(cif_content) {
  extract_value(cif_content, "_chemical_formula_sum")
}

extract_structure_type <- function(cif_content) {
  extract_value(cif_content, "_chemical_name_structure_type")
}

extract_space_group_name <- function(cif_content) {
  extract_value(cif_content, "_space_group_name_H-M_alt")
}

extract_space_group_number <- function(cif_content) {
  extract_value(cif_content, "_space_group_IT_number")
}

# Function to extract unit cell metrics
extract_unit_cell_metrics <- function(cif_content) {
  cell_parameters <- c(
    "_cell_length_a",
    "_cell_length_b",
    "_cell_length_c",
    "_cell_angle_alpha",
    "_cell_angle_beta",
    "_cell_angle_gamma"
  )
  
  # Extract and clean values for each cell parameter
  values <- sapply(cell_parameters, function(param) {
    line <- cif_content[V1 %like% param]$V1
    if (length(line) > 0) {
      value <- gsub(".*\\s+([0-9\\.]+).*", "\\1", line)
      return(as.numeric(value))
    } else {
      return(NA)
    }
  })
  
  # Create a data table with the extracted values
  unit_cell_metrics <- as.data.table(t(values))
  setnames(unit_cell_metrics, cell_parameters)
  
  return(unit_cell_metrics)
}

# Extracting atomic coordinates
extract_atomic_coordinates <- function(cif_content) {
  # Initialize lists to store atom properties
  labels <- vector()
  fractional_x <- vector()
  fractional_y <- vector()
  fractional_z <- vector()
  x_errors <- vector()
  y_errors <- vector()
  z_errors <- vector()

  # Find the start and end of the atom section
  atom_start <- grep("_atom_site_occupancy", cif_content$V1)
  atom_end <- grep("^loop_|^#End", cif_content$V1[atom_start:length(cif_content$V1)]) + atom_start - 1

  # If atom_end has multiple matches, take the first match after atom_start
  if(length(atom_end) > 1) {
    atom_end <- atom_end[1]
  }

  # Iterate over each line containing atomic coordinates
  for (line in cif_content$V1[(atom_start + 1):(atom_end - 1)]) {
    # Extract atom properties from the line
    properties <- strsplit(line, "\\s+")[[1]]

    # Extract and store relevant information
    labels <- c(labels, properties[1])

    # Extract fractional coordinates and errors separately
    fractional_x_val <- gsub("\\(.*\\)", "", properties[5])
    fractional_y_val <- gsub("\\(.*\\)", "", properties[6])
    fractional_z_val <- gsub("\\(.*\\)", "", properties[7])

    x_error <- ifelse(grepl("\\(", properties[5]), gsub(".*\\((.*)\\).*", "\\1", properties[5]), NA)
    y_error <- ifelse(grepl("\\(", properties[6]), gsub(".*\\((.*)\\).*", "\\1", properties[6]), NA)
    z_error <- ifelse(grepl("\\(", properties[7]), gsub(".*\\((.*)\\).*", "\\1", properties[7]), NA)

    fractional_x <- c(fractional_x, fractional_x_val)
    fractional_y <- c(fractional_y, fractional_y_val)
    fractional_z <- c(fractional_z, fractional_z_val)
    x_errors <- c(x_errors, x_error)
    y_errors <- c(y_errors, y_error)
    z_errors <- c(z_errors, z_error)
  }

  # Create a data table to store the atomic coordinates
  atomic_coordinates <- data.table(
    Label = labels,
    x_a = as.numeric(fractional_x),
    y_b = as.numeric(fractional_y),
    z_c = as.numeric(fractional_z),
    x_error = as.numeric(x_errors),
    y_error = as.numeric(y_errors),
    z_error = as.numeric(z_errors)
  )
  return(atomic_coordinates)
}

# Function to extract symmetry operations from CIF content
extract_symmetry_operations <- function(cif_content) {
  # Find the start and end of the symmetry operations section
  symmetry_start <- grep("_space_group_symop_operation_xyz", cif_content$V1)
  symmetry_end <- grep("^loop_", cif_content$V1[symmetry_start:length(cif_content$V1)]) + symmetry_start - 1

  if (length(symmetry_end) > 1) {
    symmetry_end <- symmetry_end[1]
  }

  # Extract lines containing symmetry operations
  symmetry_lines <- cif_content$V1[(symmetry_start + 1):(symmetry_end - 1)]
  # Split each line into components
  symmetry_operations <- str_split_fixed(symmetry_lines, ",\\s*", n = 3)

  # Create a data table with the extracted symmetry operations
  symmetry_operations <- data.table(
    x = gsub("^[0-9]+\\s+'|'", "", symmetry_operations[, 1]),
    y = gsub("^[0-9]+\\s+'|'", "", symmetry_operations[, 2]),
    z = gsub("^[0-9]+\\s+'|'", "", symmetry_operations[, 3])
  )

  return(symmetry_operations)
}

# Function to apply symmetry operations to atomic coordinates
apply_symmetry_operations <- function(atomic_coordinates, symmetry_operations) {
  # Helper function to apply a single operation
  apply_operation <- function(operation, x, y, z) {
    operation <- gsub("x", sprintf("(%f)", x), operation)
    operation <- gsub("y", sprintf("(%f)", y), operation)
    operation <- gsub("z", sprintf("(%f)", z), operation)
    eval(parse(text = operation))
  }

  # Expand coordinates by applying each symmetry operation
  expand_coordinates <- function(row) {
    x <- row$x_a
    y <- row$y_b
    z <- row$z_c
    new_coords <- rbindlist(lapply(1:nrow(symmetry_operations), function(i) {
      new_x <- apply_operation(symmetry_operations[i, x], x, y, z)
      new_y <- apply_operation(symmetry_operations[i, y], x, y, z)
      new_z <- apply_operation(symmetry_operations[i, z], x, y, z)

      data.table(
        Label = paste(row$Label, i, sep = "_"), # Apply unique label
        x_a = ifelse(new_x > 1, new_x - 1, ifelse(new_x < 0, new_x + 1, new_x)),
        y_b = ifelse(new_y > 1, new_y - 1, ifelse(new_y < 0, new_y + 1, new_y)),
        z_c = ifelse(new_z > 1, new_z - 1, ifelse(new_z < 0, new_z + 1, new_z))
      )
    }))
    return(new_coords)
  }

  # Apply symmetry operations to all atomic coordinates
  transformed_coords <- rbindlist(lapply(1:nrow(atomic_coordinates), function(i) {
    expand_coordinates(atomic_coordinates[i])
  }))

  return(transformed_coords)
}


# Function to calculate distances between atoms using real-space metric tensor and vectorization
calculate_distances <- function(transformed_coords, unit_cell_metrics) {
  # Extract unit cell parameters
  a <- unit_cell_metrics$`_cell_length_a`
  b <- unit_cell_metrics$`_cell_length_b`
  c <- unit_cell_metrics$`_cell_length_c`
  alpha <- unit_cell_metrics$`_cell_angle_alpha` * pi / 180  # Convert to radians
  beta <- unit_cell_metrics$`_cell_angle_beta` * pi / 180    # Convert to radians
  gamma <- unit_cell_metrics$`_cell_angle_gamma` * pi / 180  # Convert to radians
  
  # Calculate the real-space metric tensor components
  a2 <- a^2
  b2 <- b^2
  c2 <- c^2
  bc_cos_alpha <- b * c * cos(alpha)
  ca_cos_beta <- c * a * cos(beta)
  ab_cos_gamma <- a * b * cos(gamma)
  
  # Extract coordinates as a matrix
  coords <- as.matrix(transformed_coords[, .(x_a, y_b, z_c)])
  labels <- transformed_coords$Label
  
  # Calculate pairwise differences in coordinates
  delta_x <- outer(coords[, 1], coords[, 1], "-")
  delta_y <- outer(coords[, 2], coords[, 2], "-")
  delta_z <- outer(coords[, 3], coords[, 3], "-")
  
  # Apply periodic boundary conditions
  delta_x <- delta_x - round(delta_x)
  delta_y <- delta_y - round(delta_y)
  delta_z <- delta_z - round(delta_z)
  
  # Calculate the squared distance using the metric tensor
  r2 <- a2 * delta_x^2 + b2 * delta_y^2 + c2 * delta_z^2 +
        2 * bc_cos_alpha * delta_y * delta_z +
        2 * ca_cos_beta * delta_z * delta_x +
        2 * ab_cos_gamma * delta_x * delta_y
  
  # Calculate the distances
  r <- sqrt(r2)
  
  # Create a distance matrix with atom labels
  atom_pairs <- expand.grid(Atom1 = labels, Atom2 = labels)
  distances <- data.table(
    Atom1 = atom_pairs$Atom1,
    Atom2 = atom_pairs$Atom2,
    Distance = as.vector(r)
  )
  
  # Filter out zero distances (self-distances) and duplicates
  distances <- distances[Atom1 != Atom2 & !duplicated(t(apply(distances, 1, sort)))]

  return(distances)
}
```
# Final Processing
```{r}
# Initialize an empty data table to store the results
main_table <- data.table()

# Iterate over each CIF content
for (cif in cif_tab) {
  # Extract various properties and metrics
  ICSD_code <- extract_ICSD_code(cif)
  chemical_formula <- extract_chemical_formula(cif)
  structure_type <- extract_structure_type(cif)
  space_group_name <- extract_space_group_name(cif)
  space_group_number <- extract_space_group_number(cif)
  unit_cell_metrics <- extract_unit_cell_metrics(cif)
  atomic_coordinates <- extract_atomic_coordinates(cif)
  symmetry_operations <- extract_symmetry_operations(cif)
  transformed_coords <- apply_symmetry_operations(atomic_coordinates, symmetry_operations)
  distances <- calculate_distances(transformed_coords, unit_cell_metrics)

  # Combine extracted data into the main table
  main_table <- rbindlist(list(main_table, data.table(
    ICSD_code = ICSD_code,
    chemical_formula = chemical_formula,
    structure_type = structure_type,
    space_group_name = space_group_name,
    space_group_number = space_group_number,
    unit_cell_metrics = list(unit_cell_metrics),
    atomic_coordinates = list(atomic_coordinates),
    symmetry_operations = list(symmetry_operations),
    transformed_coords = list(transformed_coords),
    distances = list(distances)
  )), fill = TRUE)
}

# Display the final combined data table
main_table
```
