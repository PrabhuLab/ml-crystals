---
title: "flat_crystallography.Rmd for crysmal package"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
# This chunk is for setup and is not included in the final package/vignette
library(testthat)
library(data.table)
library(stringr)
library(dplyr)
```

# Introduction

This package provides a comprehensive toolkit for parsing Crystallographic Information Files (CIF) and performing detailed geometric analysis.

# 0. Globals
<!-- FIX: Renamed chunk to 'globals' and added @keywords internal. -->
<!-- This solves all "no visible binding for global variable" NOTEs during R CMD check. -->

```{r globals}
#' @keywords internal
utils::globalVariables(
  c(".", ".N", "V1", "Atom1", "Atom2", "Distance", "dcut", "dmin", 
    "DeltaX", "DeltaY", "DeltaZ", "BondStrength", "Label", "x_a", "y_b", "z_c", 
    "CentralAtom", "Neighbor1", "Neighbor2", "AngleError", "x_error", 
    "y_error", "z_error", "Original_Atom2", "term_common", "dx", "dy", "dz",
    "pd_a", "pd_b", "pd_c", "pd_alpha", "pd_beta", "pd_gamma", "pd_xf1", 
    "pd_yf1", "pd_zf1", "variance", "s_xf1", "s_yf1", "s_zf1", "pd_xf2",
    "s_xf2", "pd_yf2", "s_yf2", "pd_zf2", "s_zf2", "DistanceError",
    "xc", "yc", "zc", "i.xc", "i.yc", "i.zc", "Parent_C", "Parent_N1", 
    "Parent_N2", "i.s_xc_sq", "i.s_yc_sq", "i.s_zc_sq", "xc2", "xc1", 
    "yc2", "yc1", "zc2", "zc1", "xc3", "yc3", "zc3", "a_vx", "a_vy", "a_vz",
    "b_vx", "b_vy", "b_vz", "mag_a", "mag_b", "C_val", "s_C_sq", "p_C_xc1",
    "s_xc1_sq", "p_C_yc1", "s_yc1_sq", "p_C_zc1", "s_zc1_sq", "p_C_xc2", 
    "s_xc2_sq", "p_C_yc2", "s_yc2_sq", "p_C_zc2", "s_zc2_sq", "p_C_xc3",
    "s_xc3_sq", "p_C_yc3", "s_yc3_sq", "p_C_zc3", "s_zc3_sq", "s_theta_sq",
    "p_xc_a", "p_xc_b", "p_xc_c", "p_xc_alpha", "p_xc_beta", "p_xc_gamma",
    "p_xc_xf", "p_xc_yf", "p_xc_zf", "s_xc_sq", "p_yc_a", "p_yc_b", "p_yc_c",
    "p_yc_alpha", "p_yc_beta", "p_yc_gamma", "p_yc_xf", "p_yc_yf", "p_yc_zf",
    "s_yc_sq", "p_zc_a", "p_zc_b", "p_zc_c", "p_zc_alpha", "p_zc_beta", 
    "p_zc_gamma", "p_zc_xf", "p_zc_yf", "p_zc_zf", "s_zc_sq")
)
```

# 1. CIF Parsing Functions

## Metadata Extractors
<!-- FIX: Simplified the documentation header to use @name and @rdname for robust grouping. -->
```{r function-extractors}
#' Extract Metadata from CIF Content
#' 
#' @description A group of functions to extract specific metadata tags from CIF file content.
#' `extract_value` is the internal helper function, while the others are exported for direct use.
#' 
#' @param cif_content A data.table where each row is a line from the CIF file.
#' @param pattern The text pattern (e.g., "_database_code_") to search for.
#' @param remove_pattern A boolean indicating whether to remove the search pattern.
#'
#' @return A character string of the cleaned value, or NA if not found.
#' @name extract-helpers
NULL

#' @rdname extract-helpers
#' @keywords internal
extract_value <- function(cif_content, pattern, remove_pattern = TRUE) {
  lines <- cif_content[V1 %like% pattern]
  if (nrow(lines) > 0) {
    value <- lines$V1
    if (remove_pattern) { value <- gsub(pattern, "", value) }
    value <- gsub("'", "", value); value <- trimws(value)
    return(value)
  } else { return(NA) }
}

#' @rdname extract-helpers
#' @export
extract_database_code <- function (cif_content) { extract_value(cif_content, "_database_code_") }
#' @rdname extract-helpers
#' @export
extract_chemical_formula <- function(cif_content) { extract_value(cif_content, "_chemical_formula_sum") }
#' @rdname extract-helpers
#' @export
extract_structure_type <- function(cif_content) { extract_value(cif_content, "_chemical_name_structure_type") }
#' @rdname extract-helpers
#' @export
extract_space_group_name <- function(cif_content) { extract_value(cif_content, "_space_group_name_H-M_alt") }
#' @rdname extract-helpers
#' @export
extract_space_group_number <- function(cif_content) { extract_value(cif_content, "_space_group_IT_number") }
```

## Data Structure Extractors

```{r function-structure-extractors}
#' Extract Unit Cell Metrics and Errors
#' @description Parses unit cell parameters and their uncertainties from CIF content.
#' @param cif_content A data.table containing the lines of a CIF file.
#' @return A one-row data.table with columns for each cell parameter and its error.
#' @import data.table stringr
#' @export
extract_unit_cell_metrics <- function(cif_content) {
  cell_parameters <- c("_cell_length_a", "_cell_length_b", "_cell_length_c", "_cell_angle_alpha", "_cell_angle_beta", "_cell_angle_gamma")
  values <- list(); errors <- list()
  scale_error <- function(value_str, error_str) {
    if (is.na(error_str) || error_str == "") return(NA_real_)
    decimal_pos <- regexpr("\\.", value_str)
    if (decimal_pos == -1) { scaled_error <- as.numeric(error_str) } else {
      decimal_places <- nchar(value_str) - decimal_pos
      scaled_error <- as.numeric(error_str) * 10^(-decimal_places)
    }
    return(scaled_error)
  }
  for (param in cell_parameters) {
    line <- cif_content[V1 %like% param]$V1
    if (length(line) > 0) {
      match_res <- str_match(line, "\\s+([0-9\\.\\-]+)(?:\\(([0-9]+)\\))?")
      if (is.matrix(match_res) && nrow(match_res) > 0 && !any(is.na(match_res))) {
        value_str <- match_res[,2]; error_str <- match_res[,3]
        values[[param]] <- as.numeric(value_str)
        errors[[paste0(param, "_error")]] <- scale_error(value_str, error_str)
      } else { values[[param]] <- NA_real_; errors[[paste0(param, "_error")]] <- NA_real_ }
    } else { values[[param]] <- NA_real_; errors[[paste0(param, "_error")]] <- NA_real_ }
  }
  return(as.data.table(c(values, errors)))
}

#' Extract Atomic Coordinates
#' @description Parses atomic site information (label, coordinates, errors).
#' @param cif_content A data.table containing the lines of a CIF file.
#' @return A data.table where each row corresponds to an atom.
#' @import data.table stringr
#' @export
extract_atomic_coordinates <- function(cif_content) {
  first_header_line_idx <- grep("^_atom_site_fract_x", cif_content$V1)
  if (length(first_header_line_idx)==0) { first_header_line_idx <- grep("^_atom_site_label", cif_content$V1); if (length(first_header_line_idx)==0) return(NULL) }
  loop_start_line_idx <- max(grep("^loop_", cif_content$V1[1:first_header_line_idx]))
  if (is.infinite(loop_start_line_idx)) return(NULL)
  line_indices <- (loop_start_line_idx + 1):nrow(cif_content); headers <- character(); first_data_line_idx <- 0
  for (i in line_indices) { line <- cif_content$V1[i]; if (startsWith(line, "_")) { headers <- c(headers, trimws(line)) } else { first_data_line_idx <- i; break } }
  tags_to_find <- c(label="_atom_site_label", x="_atom_site_fract_x", y="_atom_site_fract_y", z="_atom_site_fract_z", occupancy="_atom_site_occupancy", wyckoff="_atom_site_Wyckoff_symbol", multiplicity="_atom_site_symmetry_multiplicity")
  col_indices <- sapply(tags_to_find, function(tag) { idx <- which(headers == tag); if (length(idx) == 0) NA else idx })
  if (any(is.na(col_indices[c("label", "x", "y", "z")]))) { warning("CIF missing essential atom site tags."); return(NULL) }
  end_candidates <- c(grep("^loop_|^_|^#", cif_content$V1[first_data_line_idx:nrow(cif_content)]), grep("^\\s*$", cif_content$V1[first_data_line_idx:nrow(cif_content)]))
  last_data_line_idx <- if (length(end_candidates) > 0) { first_data_line_idx + min(end_candidates) - 2 } else { nrow(cif_content) }
  if (first_data_line_idx > last_data_line_idx) return(NULL)
  data_lines <- cif_content$V1[first_data_line_idx:last_data_line_idx]
  atom_data <- fread(text = paste(data_lines, collapse="\n"), header=FALSE, sep="auto", quote="")
  parse_vector_with_error <- function(coord_vector) {
    matches <- str_match(coord_vector, "([0-9\\.\\-]+)(?:\\(([0-9]+)\\))?")
    value_str <- matches[, 2]; error_str <- matches[, 3]
    decimal_pos <- regexpr("\\.", value_str); decimal_places <- ifelse(decimal_pos == -1, 0, nchar(value_str) - decimal_pos)
    scaled_error <- as.numeric(error_str) * 10^(-decimal_places)
    return(list(value = as.numeric(value_str), error = scaled_error))
  }
  x_data <- parse_vector_with_error(atom_data[[col_indices["x"]]]); y_data <- parse_vector_with_error(atom_data[[col_indices["y"]]]); z_data <- parse_vector_with_error(atom_data[[col_indices["z"]]])
  wyckoff_multiplicity <- if (!is.na(col_indices["multiplicity"])) { as.numeric(atom_data[[col_indices["multiplicity"]]]) } else { rep(NA_real_, nrow(atom_data)) }
  atomic_coordinates <- data.table(Label=atom_data[[col_indices["label"]]], WychoffMultiplicity=wyckoff_multiplicity, x_a=x_data$value, y_b=y_data$value, z_c=z_data$value, x_error=x_data$error, y_error=y_data$error, z_error=z_data$error)
  return(atomic_coordinates)
}

#' Extract Symmetry Operations from CIF
#' @description Parses symmetry operation definitions from CIF content.
#' @param cif_content A data.table containing the lines of a CIF file.
#' @return A data.table with columns 'x', 'y', and 'z' for each operation.
#' @import data.table stringr
#' @export
extract_symmetry_operations <- function(cif_content) {
  symop_tag <- "_space_group_symop_operation_xyz"; first_header_line_idx <- grep(symop_tag, cif_content$V1)
  if (length(first_header_line_idx) == 0) { symop_tag <- "_symmetry_equiv_pos_as_xyz"; first_header_line_idx <- grep(symop_tag, cif_content$V1); if (length(first_header_line_idx) == 0) return(NULL) }
  loop_start_line_idx <- max(grep("^loop_", cif_content$V1[1:first_header_line_idx])); if (is.infinite(loop_start_line_idx)) return(NULL)
  line_indices <- (loop_start_line_idx + 1):nrow(cif_content); first_data_line_idx <- 0
  for (i in line_indices) { if (!startsWith(cif_content$V1[i], "_")) { first_data_line_idx <- i; break } }; if (first_data_line_idx == 0) return(NULL)
  end_candidates <- c(grep("^loop_|^_|^#", cif_content$V1[first_data_line_idx:nrow(cif_content)]), grep("^\\s*$", cif_content$V1[first_data_line_idx:nrow(cif_content)]))
  last_data_line_idx <- if (length(end_candidates) > 0) { first_data_line_idx + min(end_candidates) - 2 } else { nrow(cif_content) }
  if (first_data_line_idx > last_data_line_idx) return(NULL)
  data_lines <- cif_content$V1[first_data_line_idx:last_data_line_idx]
  cleaned_lines <- trimws(gsub("^'|^\"|'$|\"$", "", trimws(sub("^[0-9]+\\s+", "", data_lines))))
  symmetry_matrix <- str_split_fixed(cleaned_lines, ",", n = 3)
  return(data.table(x = trimws(symmetry_matrix[, 1]), y = trimws(symmetry_matrix[, 2]), z = trimws(symmetry_matrix[, 3])))
}
```

# 2. Crystal Structure Generation

```{r function-structure-generation}
#' Apply Symmetry Operations
#' @description Generates all symmetry-equivalent atomic positions.
#' @param atomic_coordinates A data.table from `extract_atomic_coordinates`.
#' @param symmetry_operations A data.table from `extract_symmetry_operations`.
#' @return A data.table containing all unique atomic positions in the unit cell.
#' @import data.table dplyr
#' @export
apply_symmetry_operations <- function(atomic_coordinates, symmetry_operations) {
  apply_op <- function(op, x, y, z) { op <- gsub("x",sprintf("(%f)",x), op); op <- gsub("y",sprintf("(%f)",y),op); op <- gsub("z",sprintf("(%f)",z),op); eval(parse(text=op)) }
  expand_coords <- function(row, sym_ops) {
    x <- row$x_a; y <- row$y_b; z <- row$z_c
    new_coords <- rbindlist(lapply(1:nrow(sym_ops), function(i) {
      data.table(Label=paste(row$Label,i,sep="_"), x_a=apply_op(sym_ops[i,x],x,y,z)%%1, y_b=apply_op(sym_ops[i,y],x,y,z)%%1, z_c=apply_op(sym_ops[i,z],x,y,z)%%1)
    }))
    return(new_coords)
  }
  transformed_coords <- rbindlist(lapply(1:nrow(atomic_coordinates), function(i) expand_coords(atomic_coordinates[i,], symmetry_operations)))
  return(transformed_coords %>% distinct(x_a, y_b, z_c, .keep_all = TRUE))
}

#' Expand to Neighboring Unit Cells
#' @description Replicates atoms into a 3x3x3 supercell grid.
#' @param transformed_coords A data.table of atom positions within one unit cell.
#' @return A data.table containing all atomic positions in the expanded supercell.
#' @import data.table dplyr
#' @export
expand_transformed_coords <- function(transformed_coords) {
  cell_indices <- as.data.table(expand.grid(x=-1:1, y=-1:1, z=-1:1))
  expanded_coords <- rbindlist(lapply(1:nrow(cell_indices), function(i) {
    shift <- cell_indices[i,]; transformed_coords[,.(Label=paste(Label,paste(shift$x,shift$y,shift$z,sep="_"),sep="_"), x_a=x_a+shift$x, y_b=y_b+shift$y, z_c=z_c+shift$z)]
  }))
  return(expanded_coords %>% distinct(x_a, y_b, z_c, .keep_all = TRUE))
}
```

# 3. Geometric Calculations

## Distance and Neighbor Functions

```{r function-geometric-calcs}
#' Calculate Interatomic Distances
#' @description Computes distances between atoms using the metric tensor.
#' @param atomic_coordinates The primary set of asymmetric atoms.
#' @param expanded_coords The set of atoms in the supercell.
#' @param unit_cell_metrics A data.table with cell parameters.
#' @return A data.table of all non-zero distances.
#' @import data.table
#' @export
calculate_distances <- function(atomic_coordinates, expanded_coords, unit_cell_metrics) {
  a<-unit_cell_metrics$`_cell_length_a`; b<-unit_cell_metrics$`_cell_length_b`; c<-unit_cell_metrics$`_cell_length_c`
  alpha<-unit_cell_metrics$`_cell_angle_alpha`*pi/180; beta<-unit_cell_metrics$`_cell_angle_beta`*pi/180; gamma<-unit_cell_metrics$`_cell_angle_gamma`*pi/180
  coords_atomic<-as.matrix(atomic_coordinates[,.(x_a,y_b,z_c)]); coords_expanded<-as.matrix(expanded_coords[,.(x_a,y_b,z_c)])
  labels_atomic<-atomic_coordinates$Label; labels_expanded<-expanded_coords$Label
  delta_x<-outer(coords_atomic[,1],coords_expanded[,1],"-"); delta_y<-outer(coords_atomic[,2],coords_expanded[,2],"-"); delta_z<-outer(coords_atomic[,3],coords_expanded[,3],"-")
  cos_alpha<-cos(alpha); cos_beta<-cos(beta); cos_gamma<-cos(gamma)
  r2 <- (a^2*delta_x^2)+(b^2*delta_y^2)+(c^2*delta_z^2)+(2*b*c*cos_alpha*delta_y*delta_z)+(2*c*a*cos_beta*delta_z*delta_x)+(2*a*b*cos_gamma*delta_x*delta_y)
  r <- sqrt(r2)
  atom_pairs <- expand.grid(Atom1=labels_atomic, Atom2=labels_expanded, KEEP.OUT.ATTRS=TRUE, stringsAsFactors = FALSE)
  distances <- data.table(Atom1=atom_pairs$Atom1, Atom2=atom_pairs$Atom2, Distance=as.vector(r), DeltaX=as.vector(delta_x), DeltaY=as.vector(delta_y), DeltaZ=as.vector(delta_z))
  return(distances[Distance > 1e-6, ])
}

#' Calculate Neighbor Counts
#' @description Counts nearest neighbors for each central atom.
#' @param bonded_pairs_table A data.table of bonded pairs.
#' @return A data.table with columns 'Atom' and 'NeighborCount'.
#' @import data.table
#' @export
calculate_neighbor_counts <- function(bonded_pairs_table) {
  if (is.null(bonded_pairs_table) || nrow(bonded_pairs_table) == 0) {
    return(data.table(Atom = character(), NeighborCount = integer()))
  }
  neighbor_counts <- bonded_pairs_table[, .(NeighborCount = .N), by = .(Atom1)]
  setnames(neighbor_counts, "Atom1", "Atom")
  return(neighbor_counts)
}

#' Calculate Bond Angles
#' @description Calculates all bond angles centered on each atom.
#' @param bonded_pairs Data.table of bonded atoms.
#' @param atomic_coordinates Data.table of asymmetric atom coordinates.
#' @param expanded_coords Data.table of supercell atom coordinates.
#' @param unit_cell_metrics Data.table with unit cell parameters.
#' @return A data.table of all unique bond angles.
#' @import data.table utils
#' @export
calculate_angles <- function(bonded_pairs, atomic_coordinates, expanded_coords, unit_cell_metrics) {
  a<-unit_cell_metrics$`_cell_length_a`; b<-unit_cell_metrics$`_cell_length_b`; c<-unit_cell_metrics$`_cell_length_c`
  alpha_rad<-unit_cell_metrics$`_cell_angle_alpha`*pi/180; beta_rad<-unit_cell_metrics$`_cell_angle_beta`*pi/180; gamma_rad<-unit_cell_metrics$`_cell_angle_gamma`*pi/180
  cos_alpha<-cos(alpha_rad); cos_beta<-cos(beta_rad); cos_gamma<-cos(gamma_rad)
  all_coords <- unique(rbind(atomic_coordinates[,.(Label,x_a,y_b,z_c)], expanded_coords[,.(Label,x_a,y_b,z_c)]), by="Label"); setkey(all_coords, Label)
  calculate_angle_metric <- function(c_atom, n1_atom, n2_atom) {
    coord1<-all_coords[c_atom,.(x_a,y_b,z_c)]; coord2<-all_coords[n1_atom,.(x_a,y_b,z_c)]; coord3<-all_coords[n2_atom,.(x_a,y_b,z_c)]
    if(anyNA(coord1)|anyNA(coord2)|anyNA(coord3)) return(NA_real_)
    v1_frac<-as.numeric(coord2-coord1); v2_frac<-as.numeric(coord3-coord1)
    xf1<-v1_frac;yf1<-v1_frac;zf1<-v1_frac; xf2<-v2_frac;yf2<-v2_frac;zf2<-v2_frac
    dot_prod<-(xf1*xf2*a^2+yf1*yf2*b^2+zf1*zf2*c^2+(xf1*yf2+yf1*xf2)*a*b*cos_gamma+(xf1*zf2+zf1*xf2)*a*c*cos_beta+(yf1*zf2+zf1*yf2)*b*c*cos_alpha)
    mag_sq1<-(xf1^2*a^2+yf1^2*b^2+zf1^2*c^2+2*xf1*yf1*a*b*cos_gamma+2*xf1*zf1*a*c*cos_beta+2*yf1*zf1*b*c*cos_alpha)
    mag_sq2<-(xf2^2*a^2+yf2^2*b^2+zf2^2*c^2+2*xf2*yf2*a*b*cos_gamma+2*xf2*zf2*a*c*cos_beta+2*yf2*zf2*b*c*cos_alpha)
    if (mag_sq1<=1e-10||mag_sq2<=1e-10) return(NA_real_)
    cos_theta <- min(max(dot_prod/(sqrt(mag_sq1)*sqrt(mag_sq2)),-1.0),1.0)
    return(acos(cos_theta)*180/pi)
  }
  angle_list <- list()
  unique_central_atoms <- unique(bonded_pairs$Atom1)
  for (central_atom in unique_central_atoms) {
    bonded_neighbors <- bonded_pairs[Atom1==central_atom, Atom2]
    if (length(bonded_neighbors) >= 2) {
      neighbor_combinations <- combn(bonded_neighbors, 2, simplify=FALSE)
      for (pair in neighbor_combinations) {
        angle <- calculate_angle_metric(central_atom, pair, pair)
        if (!is.na(angle)) {
          angle_list[[length(angle_list)+1]] <- data.table(CentralAtom=central_atom, Neighbor1=pair, Neighbor2=pair, Angle=angle)
        }
      }
    }
  }
  if (length(angle_list)>0) { return(rbindlist(angle_list)[order(CentralAtom, Neighbor1, Neighbor2)]) } else {
    return(data.table(CentralAtom=character(),Neighbor1=character(),Neighbor2=character(),Angle=numeric()))
  }
}
```

## Bonding Identification Methods

```{r function-minimum-distance}
#' Minimum Distance Method for Bonding
#' @description Identifies bonded atoms using the nearest neighbor distance plus a tolerance.
#' @param distances A data.table of interatomic distances from `calculate_distances`.
#' @param delta The relative tolerance parameter (default 0.1).
#' @return A data.table of bonded pairs.
#' @import data.table
#' @export
minimum_distance <- function(distances, delta = 0.1) {
  if (nrow(distances) == 0) return(data.table())
  dmin <- distances[, .(dmin = min(Distance)), by = .(Atom1)]
  dmin[, dcut := (1 + delta) * dmin]
  bonded_pairs <- distances[dmin, on = .(Atom1), allow.cartesian = TRUE][Distance <= dcut, .(Atom1, Atom2, Distance, DeltaX, DeltaY, DeltaZ, dcut, dmin)]
  return(bonded_pairs)
}
```

```{r function-brunner}
#' Brunner's Largest Reciprocal Gap Method
#' @description An alternative bonding detection method.
#' @param distances data.table of interatomic distances.
#' @param delta Small tolerance value.
#' @return A data.table of bonded pairs.
#' @import data.table
#' @export
brunner <- function(distances, delta = 0.0001) {
  bonds <- list()
  unique_atoms <- unique(distances$Atom1)
  for (atom in unique_atoms) {
    atom_distances <- distances[Atom1 == atom][order(Distance)]
    if (nrow(atom_distances) < 2) next
    largest_gap <- -Inf; j_max <- NA
    for (j in 1:(nrow(atom_distances) - 1)) {
      reciprocal_gap <- 1 / atom_distances$Distance[j] - 1 / atom_distances$Distance[j + 1]
      if (reciprocal_gap > largest_gap) { largest_gap <- reciprocal_gap; j_max <- j }
    }
    if(is.na(j_max)) next
    d_cut <- atom_distances$Distance[j_max] + delta
    bonds[[atom]] <- atom_distances[Distance <= d_cut, ]
  }
  return(rbindlist(bonds, fill = TRUE))
}
```

```{r function-hoppe}
#' Hoppe's Method of Effective Coordination Numbers
#' @description An alternative bonding detection method.
#' @param distances data.table of interatomic distances.
#' @param delta Tolerance parameter.
#' @param tolerance Convergence tolerance.
#' @return A data.table of bonded pairs.
#' @import data.table
#' @export
hoppe <- function(distances, delta = 0.5, tolerance = 0.001) {
  bonded_pairs <- list()
  unique_atoms <- unique(distances$Atom1)
  for (atom in unique_atoms) {
    atom_distances <- distances[Atom1 == atom]
    if(nrow(atom_distances) == 0) next
    dmin <- min(atom_distances$Distance)
    davg <- sum(atom_distances$Distance * exp(1 - (atom_distances$Distance/dmin)^6)) / sum(exp(1 - (atom_distances$Distance/dmin)^6))
    while (TRUE) {
      prev_davg <- davg
      davg <- sum(atom_distances$Distance*exp(1-(atom_distances$Distance/prev_davg)^6)) / sum(exp(1-(atom_distances$Distance/prev_davg)^6))
      if (abs(davg - prev_davg) <= tolerance) break
    }
    atom_distances[, BondStrength := exp(1 - (Distance / davg)^6)]
    bonded_pairs[[atom]] <- atom_distances[BondStrength >= delta, .(Atom1, Atom2, Distance)]
  }
  return(rbindlist(bonded_pairs, fill = TRUE))
}
```

# 4. Error Propagation Functions

```{r function-error-propagation}
#' Propagate Distance Error
#' @description Calculates the standard uncertainty for each interatomic distance.
#' @param bonded_pairs Data.table of bonded atoms with their distances.
#' @param atomic_coordinates Data.table with fractional coordinates and errors.
#' @param unit_cell_metrics Data.table with unit cell parameters and errors.
#' @return The input `bonded_pairs` data.table with a new 'DistanceError' column.
#' @import data.table
#' @export
propagate_distance_error <- function(bonded_pairs, atomic_coordinates, unit_cell_metrics) {
  if (is.null(bonded_pairs) || nrow(bonded_pairs) == 0) { if(!is.null(bonded_pairs)) bonded_pairs[, DistanceError := NA_real_]; return(bonded_pairs) }
  a<-unit_cell_metrics$`_cell_length_a`;s_a<-unit_cell_metrics$`_cell_length_a_error`;b<-unit_cell_metrics$`_cell_length_b`;s_b<-unit_cell_metrics$`_cell_length_b_error`;c<-unit_cell_metrics$`_cell_length_c`;s_c<-unit_cell_metrics$`_cell_length_c_error`
  alpha_rad<-unit_cell_metrics$`_cell_angle_alpha`*pi/180;s_alpha_rad<-unit_cell_metrics$`_cell_angle_alpha_error`*pi/180;beta_rad<-unit_cell_metrics$`_cell_angle_beta`*pi/180;s_beta_rad<-unit_cell_metrics$`_cell_angle_beta_error`*pi/180;gamma_rad<-unit_cell_metrics$`_cell_angle_gamma`*pi/180;s_gamma_rad<-unit_cell_metrics$`_cell_angle_gamma_error`*pi/180
  cos_a<-cos(alpha_rad);sin_a<-sin(alpha_rad);cos_b<-cos(beta_rad);sin_b<-sin(beta_rad);cos_g<-cos(gamma_rad);sin_g<-sin(gamma_rad)
  s_a<-ifelse(is.na(s_a),0,s_a);s_b<-ifelse(is.na(s_b),0,s_b);s_c<-ifelse(is.na(s_c),0,s_c);s_alpha_rad<-ifelse(is.na(s_alpha_rad),0,s_alpha_rad);s_beta_rad<-ifelse(is.na(s_beta_rad),0,s_beta_rad);s_gamma_rad<-ifelse(is.na(s_gamma_rad),0,s_gamma_rad)
  work_dt<-copy(bonded_pairs);setnames(work_dt,c("DeltaX","DeltaY","DeltaZ"),c("dx","dy","dz"));atom_errors<-atomic_coordinates[,.(Label,s_xf=x_error,s_yf=y_error,s_zf=z_error)]
  work_dt<-merge(work_dt,atom_errors,by.x="Atom1",by.y="Label",all.x=TRUE);setnames(work_dt,c("s_xf","s_yf","s_zf"),c("s_xf1","s_yf1","s_zf1"));work_dt[,Original_Atom2:=sub("_.*","",Atom2)];work_dt<-merge(work_dt,atom_errors,by.x="Original_Atom2",by.y="Label",all.x=TRUE);setnames(work_dt,c("s_xf","s_yf","s_zf"),c("s_xf2","s_yf2","s_zf2"));work_dt[,Original_Atom2:=NULL]
  coord_err_cols<-c("s_xf1","s_yf1","s_zf1","s_xf2","s_yf2","s_zf2");for(col in coord_err_cols)set(work_dt,which(is.na(work_dt[[col]])),col,0)
  work_dt[,term_common:=1/(2*Distance)];work_dt[,pd_a:=term_common*(2*a*dx^2+2*b*dx*dy*cos_g+2*c*dx*dz*cos_b)];work_dt[,pd_b:=term_common*(2*b*dy^2+2*a*dx*dy*cos_g+2*c*dy*dz*cos_a)];work_dt[,pd_c:=term_common*(2*c*dz^2+2*a*dx*dz*cos_b+2*b*dy*dz*cos_a)];work_dt[,pd_alpha:=term_common*(-2*b*c*dy*dz*sin_a)];work_dt[,pd_beta:=term_common*(-2*a*c*dx*dz*sin_b)];work_dt[,pd_gamma:=term_common*(-2*a*b*dx*dy*sin_g)]
  work_dt[,pd_xf1:=term_common*(2*a^2*dx+2*a*b*dy*cos_g+2*a*c*dz*cos_b)];work_dt[,pd_yf1:=term_common*(2*b^2*dy+2*a*b*dx*cos_g+2*b*c*dz*cos_a)];work_dt[,pd_zf1:=term_common*(2*c^2*dz+2*a*c*dx*cos_b+2*b*c*dy*cos_a)];work_dt[,`:=`(pd_xf2=-pd_xf1,pd_yf2=-pd_yf1,pd_zf2=-pd_zf1)]
  work_dt[,variance:=(pd_a*s_a)^2+(pd_b*s_b)^2+(pd_c*s_c)^2+(pd_alpha*s_alpha_rad)^2+(pd_beta*s_beta_rad)^2+(pd_gamma*s_gamma_rad)^2+(pd_xf1*s_xf1)^2+(pd_yf1*s_yf1)^2+(pd_zf1*s_zf1)^2+(pd_xf2*s_xf2)^2+(pd_yf2*s_yf2)^2+(pd_zf2*s_zf2)^2];work_dt[,DistanceError:=sqrt(variance)]
  return(merge(bonded_pairs,work_dt[,.(Atom1,Atom2,Distance,DistanceError)],by=c("Atom1","Atom2","Distance"),all.x=TRUE))
}

#' Propagate Angle Error
#' @description Calculates the standard uncertainty for each bond angle.
#' @param bond_angles Data.table of calculated bond angles.
#' @param atomic_coordinates Data.table with fractional coordinates and errors.
#' @param expanded_coords Data.table of supercell atom coordinates.
#' @param unit_cell_metrics Data.table with unit cell parameters and errors.
#' @return The input `bond_angles` data.table with a new 'AngleError' column.
#' @import data.table
#' @export
propagate_angle_error <- function(bond_angles, atomic_coordinates, expanded_coords, unit_cell_metrics) {
  if(is.null(bond_angles)||nrow(bond_angles)==0){if(!is.null(bond_angles))bond_angles[,AngleError:=NA_real_];return(bond_angles)}
  a<-unit_cell_metrics$`_cell_length_a`;b<-unit_cell_metrics$`_cell_length_b`;c<-unit_cell_metrics$`_cell_length_c`;s_a<-ifelse(is.na(unit_cell_metrics$`_cell_length_a_error`),0,unit_cell_metrics$`_cell_length_a_error`);s_b<-ifelse(is.na(unit_cell_metrics$`_cell_length_b_error`),0,unit_cell_metrics$`_cell_length_b_error`);s_c<-ifelse(is.na(unit_cell_metrics$`_cell_length_c_error`),0,unit_cell_metrics$`_cell_length_c_error`);alpha_rad<-unit_cell_metrics$`_cell_angle_alpha`*pi/180;beta_rad<-unit_cell_metrics$`_cell_angle_beta`*pi/180;gamma_rad<-unit_cell_metrics$`_cell_angle_gamma`*pi/180;s_alpha_rad<-ifelse(is.na(unit_cell_metrics$`_cell_angle_alpha_error`),0,unit_cell_metrics$`_cell_angle_alpha_error`*pi/180);s_beta_rad<-ifelse(is.na(unit_cell_metrics$`_cell_angle_beta_error`),0,unit_cell_metrics$`_cell_angle_beta_error`*pi/180);s_gamma_rad<-ifelse(is.na(unit_cell_metrics$`_cell_angle_gamma_error`),0,unit_cell_metrics$`_cell_angle_gamma_error`*pi/180)
  cos_a<-cos(alpha_rad);sin_a<-sin(alpha_rad);cos_b<-cos(beta_rad);sin_b<-sin(beta_rad);cos_g<-cos(gamma_rad);sin_g<-sin(gamma_rad);v_sq<-1-cos_a^2-cos_b^2-cos_g^2+2*cos_a*cos_b*cos_g;v<-sqrt(v_sq)
  cart_errors<-copy(atomic_coordinates);for(col in c("x_error","y_error","z_error"))set(cart_errors,which(is.na(cart_errors[[col]])),col,0)
  cart_errors[,`:=`(p_xc_a=x_a,p_xc_b=y_b*cos_g,p_xc_c=z_c*cos_b,p_xc_alpha=0,p_xc_beta=-c*z_c*sin_b,p_xc_gamma=-b*y_b*sin_g,p_xc_xf=a,p_xc_yf=b*cos_g,p_xc_zf=c*cos_b,p_yc_a=0,p_yc_b=y_b*sin_g,p_yc_c=z_c*(cos_a-cos_b*cos_g)/sin_g,p_yc_alpha=-c*z_c*sin_a/sin_g,p_yc_beta=c*z_c*sin_b*cos_g/sin_g,p_yc_gamma=b*y_b*cos_g+c*z_c*(cos_b-cos_a*cos_g)/sin_g^2,p_yc_xf=0,p_yc_yf=b*sin_g,p_yc_zf=c*(cos_a-cos_b*cos_g)/sin_g,p_zc_a=0,p_zc_b=0,p_zc_c=z_c*v/sin_g,p_zc_alpha=c*z_c*(cos_b*cos_g-cos_a)/(sin_g*v),p_zc_beta=c*z_c*(cos_a*cos_g-cos_b)/(sin_g*v),p_zc_gamma=-c*z_c*(v_sq*cos_g+sin_g^2*(cos_a*cos_b-cos_g))/(sin_g^2*v),p_zc_xf=0,p_zc_yf=0,p_zc_zf=c*v/sin_g)]
  cart_errors[,s_xc_sq:=(p_xc_a*s_a)^2+(p_xc_b*s_b)^2+(p_xc_c*s_c)^2+(p_xc_alpha*s_alpha_rad)^2+(p_xc_beta*s_beta_rad)^2+(p_xc_gamma*s_gamma_rad)^2+(p_xc_xf*x_error)^2+(p_xc_yf*y_error)^2+(p_xc_zf*z_error)^2];cart_errors[,s_yc_sq:=(p_yc_a*s_a)^2+(p_yc_b*s_b)^2+(p_yc_c*s_c)^2+(p_yc_alpha*s_alpha_rad)^2+(p_yc_beta*s_beta_rad)^2+(p_yc_gamma*s_gamma_rad)^2+(p_yc_xf*x_error)^2+(p_yc_yf*y_error)^2+(p_yc_zf*z_error)^2];cart_errors[,s_zc_sq:=(p_zc_a*s_a)^2+(p_zc_b*s_b)^2+(p_zc_c*s_c)^2+(p_zc_alpha*s_alpha_rad)^2+(p_zc_beta*s_beta_rad)^2+(p_zc_gamma*s_gamma_rad)^2+(p_zc_xf*x_error)^2+(p_zc_yf*y_error)^2+(p_zc_zf*z_error)^2]
  all_frac_coords<-unique(rbind(atomic_coordinates[,.(Label,x_a,y_b,z_c)],expanded_coords),by="Label");all_cart_coords<-all_frac_coords[,`:=`(xc=a*x_a+b*y_b*cos_g+c*z_c*cos_b,yc=b*y_b*sin_g+c*z_c*(cos_a-cos_b*cos_g)/sin_g,zc=c*z_c*v/sin_g)][,.(Label,xc,yc,zc)];setkey(all_cart_coords,Label)
  error_subset<-cart_errors[,.(Label,s_xc_sq,s_yc_sq,s_zc_sq)];setkey(error_subset,Label);work_dt<-copy(bond_angles)
  work_dt[all_cart_coords,on=.(CentralAtom=Label),`:=`(xc1=i.xc,yc1=i.yc,zc1=i.zc)];work_dt[all_cart_coords,on=.(Neighbor1=Label),`:=`(xc2=i.xc,yc2=i.yc,zc2=i.zc)];work_dt[all_cart_coords,on=.(Neighbor2=Label),`:=`(xc3=i.xc,yc3=i.yc,zc3=i.zc)]
  work_dt[,Parent_C:=sub("_.*","",CentralAtom)];work_dt[,Parent_N1:=sub("_.*","",Neighbor1)];work_dt[,Parent_N2:=sub("_.*","",Neighbor2)]
  work_dt[error_subset,on=.(Parent_C=Label),`:=`(s_xc1_sq=i.s_xc_sq,s_yc1_sq=i.s_yc_sq,s_zc1_sq=i.s_zc_sq)];work_dt[error_subset,on=.(Parent_N1=Label),`:=`(s_xc2_sq=i.s_xc_sq,s_yc2_sq=i.s_yc_sq,s_zc2_sq=i.s_zc_sq)];work_dt[error_subset,on=.(Parent_N2=Label),`:=`(s_xc3_sq=i.s_xc_sq,s_yc3_sq=i.s_yc_sq,s_zc3_sq=i.s_zc_sq)]
  work_dt[,`:=`(a_vx=xc2-xc1,a_vy=yc2-yc1,a_vz=zc2-zc1,b_vx=xc3-xc1,b_vy=yc3-yc1,b_vz=zc3-zc1)];work_dt[,`:=`(mag_a=sqrt(a_vx^2+a_vy^2+a_vz^2),mag_b=sqrt(b_vx^2+b_vy^2+b_vz^2))];work_dt<-work_dt[mag_a>1e-9&mag_b>1e-9]
  work_dt[,C_val:=(a_vx*b_vx+a_vy*b_vy+a_vz*b_vz)/(mag_a*mag_b)];work_dt[,C_val:=pmin(pmax(C_val,-1.0),1.0)]
  work_dt[,`:=`(p_C_xc1=-(((b_vx/mag_b-C_val*a_vx/mag_a)/mag_a)+((a_vx/mag_a-C_val*b_vx/mag_b)/mag_b)),p_C_yc1=-(((b_vy/mag_b-C_val*a_vy/mag_a)/mag_a)+((a_vy/mag_a-C_val*b_vy/mag_b)/mag_b)),p_C_zc1=-(((b_vz/mag_b-C_val*a_vz/mag_a)/mag_a)+((a_vz/mag_a-C_val*b_vz/mag_b)/mag_b)),p_C_xc2=(b_vx/mag_b-C_val*a_vx/mag_a)/mag_a,p_C_yc2=(b_vy/mag_b-C_val*a_vy/mag_a)/mag_a,p_C_zc2=(b_vz/mag_b-C_val*a_vz/mag_a)/mag_a,p_C_xc3=(a_vx/mag_a-C_val*b_vx/mag_b)/mag_b,p_C_yc3=(a_vy/mag_a-C_val*b_vy/mag_b)/mag_b,p_C_zc3=(a_vz/mag_a-C_val*b_vz/mag_b)/mag_b)]
  work_dt[,s_C_sq:=(p_C_xc1^2*s_xc1_sq)+(p_C_yc1^2*s_yc1_sq)+(p_C_zc1^2*s_zc1_sq)+(p_C_xc2^2*s_xc2_sq)+(p_C_yc2^2*s_yc2_sq)+(p_C_zc2^2*s_zc2_sq)+(p_C_xc3^2*s_xc3_sq)+(p_C_yc3^2*s_yc3_sq)+(p_C_zc3^2*s_zc3_sq)];work_dt[C_val^2>=1.0,s_theta_sq:=0];work_dt[C_val^2<1.0,s_theta_sq:=s_C_sq/(1-C_val^2)]
  work_dt[,AngleError:=sqrt(pmax(0,s_theta_sq))*180/pi]
  return(merge(bond_angles,work_dt[,.(CentralAtom,Neighbor1,Neighbor2,AngleError)],by=c("CentralAtom","Neighbor1","Neighbor2"),all.x=TRUE))
}
```

# 5. Main Processing Pipeline

```{r function-main-pipeline}
#' Process a List of CIF Files
#' @description The main wrapper function that iterates through CIF files,
#' applies all analysis steps, and compiles the results.
#' @param cif_list A character vector of paths to CIF files.
#' @return A single data.table where each row represents one processed CIF file.
#' @import data.table
#' @export
process_cif_files <- function(cif_list) {
  # FIX: Removed the unused `warn = FALSE` argument from the fread call.
  cif_tab_list <- lapply(cif_list, fread, sep = "\n", header = FALSE, col.names = "V1")
  
  results_list <- list()
  for (i in seq_along(cif_tab_list)) {
    cif <- cif_tab_list[[i]]; cif_path <- cif_list[i]
    result <- tryCatch({
      database_code<-extract_database_code(cif); chemical_formula<-extract_chemical_formula(cif)
      unit_cell_metrics<-extract_unit_cell_metrics(cif); atomic_coordinates<-extract_atomic_coordinates(cif); symmetry_operations<-extract_symmetry_operations(cif)
      if(is.null(atomic_coordinates)||is.null(symmetry_operations)||is.null(unit_cell_metrics)||nrow(atomic_coordinates)==0) stop("Essential data missing.")
      transformed_coords<-apply_symmetry_operations(atomic_coordinates,symmetry_operations); expanded_coords<-expand_transformed_coords(transformed_coords)
      distances<-calculate_distances(atomic_coordinates,expanded_coords,unit_cell_metrics); bonded_pairs<-minimum_distance(distances)
      neighbor_counts<-calculate_neighbor_counts(bonded_pairs); bond_angles<-calculate_angles(bonded_pairs,atomic_coordinates,expanded_coords,unit_cell_metrics)
      brunner_pairs <- brunner(distances); hoppe_pairs <- hoppe(distances)
      bonded_pairs_with_error<-propagate_distance_error(bonded_pairs,atomic_coordinates,unit_cell_metrics); bond_angles_with_error<-propagate_angle_error(bond_angles,atomic_coordinates,expanded_coords,unit_cell_metrics)
      
      data.table(
        file_path = cif_path,
        database_code = database_code,
        chemical_formula = chemical_formula,
        unit_cell_metrics = list(unit_cell_metrics),
        atomic_coordinates = list(atomic_coordinates),
        symmetry_operations = list(symmetry_operations),
        transformed_coords = list(transformed_coords),
        expanded_coords = list(expanded_coords),
        distances = list(distances),
        bonded_pairs = list(bonded_pairs_with_error),
        brunner_pairs = list(brunner_pairs),
        hoppe_pairs = list(hoppe_pairs),
        neighbor_counts = list(neighbor_counts),
        bond_angles = list(bond_angles_with_error)
      )
    }, error = function(e) {
      warning(paste("Failed to process file:", cif_path, "\nError:", e$message)); return(NULL)
    })
    results_list[[i]] <- result
  }
  return(rbindlist(results_list, fill = TRUE))
}
```

```{r examples-main-pipeline}
cif_file_path <- system.file("extdata", "ICSD422.cif", package = "crysmal")
if(nchar(cif_file_path) > 0) {
  all_data <- process_cif_files(cif_list = c(cif_file_path))
  print(all_data)
}
```

```{r tests-main-pipeline}
test_that("Main processing pipeline runs correctly", {
  cif_file_path <- system.file("extdata", "ICSD422.cif", package = "crysmal")
  skip_if(nchar(cif_file_path) == 0, "Sample data not found, skipping test.")
  
  results <- process_cif_files(c(cif_file_path))
  
  expect_s3_class(results, "data.table")
  expect_equal(nrow(results), 1)
  expect_equal(results$database_code, "ICSD 422")
  expect_s3_class(results$bonded_pairs[], "data.table")
  expect_true("DistanceError" %in% names(results$bonded_pairs[]))
})
```
