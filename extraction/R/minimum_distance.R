# WARNING - Generated by {fusen} from dev/flat_crystallography.Rmd: do not edit by hand # nolint: line_length_linter.

#' Brunner's Largest Reciprocal Gap Method
#' @description An alternative bonding detection method.
#' @param distances data.table of interatomic distances.
#' @param delta Small tolerance value.
#' @return A data.table of bonded pairs.
#' @import data.table
#' @export
brunner <- function(distances, delta = 0.0001) {
  bonds <- list()
  unique_atoms <- unique(distances$Atom1)
  for (atom in unique_atoms) {
    atom_distances <- distances[Atom1 == atom][order(Distance)]
    if (nrow(atom_distances) < 2) next
    largest_gap <- -Inf; j_max <- NA
    for (j in 1:(nrow(atom_distances) - 1)) {
      reciprocal_gap <- 1 / atom_distances$Distance[j] - 1 / atom_distances$Distance[j + 1]
      if (reciprocal_gap > largest_gap) { largest_gap <- reciprocal_gap; j_max <- j }
    }
    if(is.na(j_max)) next
    d_cut <- atom_distances$Distance[j_max] + delta
    bonds[[atom]] <- atom_distances[Distance <= d_cut, ]
  }
  return(rbindlist(bonds, fill = TRUE))
}

#' Hoppe's Method of Effective Coordination Numbers
#' @description An alternative bonding detection method.
#' @param distances data.table of interatomic distances.
#' @param delta Tolerance parameter.
#' @param tolerance Convergence tolerance.
#' @return A data.table of bonded pairs.
#' @import data.table
#' @export
hoppe <- function(distances, delta = 0.5, tolerance = 0.001) {
  bonded_pairs <- list()
  unique_atoms <- unique(distances$Atom1)
  for (atom in unique_atoms) {
    atom_distances <- distances[Atom1 == atom]
    if(nrow(atom_distances) == 0) next
    dmin <- min(atom_distances$Distance)
    davg <- sum(atom_distances$Distance * exp(1 - (atom_distances$Distance/dmin)^6)) / sum(exp(1 - (atom_distances$Distance/dmin)^6))
    while (TRUE) {
      prev_davg <- davg
      davg <- sum(atom_distances$Distance*exp(1-(atom_distances$Distance/prev_davg)^6)) / sum(exp(1-(atom_distances$Distance/prev_davg)^6))
      if (abs(davg - prev_davg) <= tolerance) break
    }
    atom_distances[, BondStrength := exp(1 - (Distance / davg)^6)]
    bonded_pairs[[atom]] <- atom_distances[BondStrength >= delta, .(Atom1, Atom2, Distance)]
  }
  return(rbindlist(bonded_pairs, fill = TRUE))
}

#' Minimum Distance Method for Bonding
#' @description Identifies bonded atoms using the nearest neighbor distance plus a tolerance.
#' @param distances A data.table of interatomic distances from `calculate_distances`.
#' @param delta The relative tolerance parameter (default 0.1).
#' @return A data.table of bonded pairs.
#' @import data.table
#' @export
minimum_distance <- function(distances, delta = 0.1) {
  if (nrow(distances) == 0) return(data.table())
  dmin <- distances[, .(dmin = min(Distance)), by = .(Atom1)]
  dmin[, dcut := (1 + delta) * dmin]
  bonded_pairs <- distances[dmin, on = .(Atom1), allow.cartesian = TRUE][Distance <= dcut, .(Atom1, Atom2, Distance, DeltaX, DeltaY, DeltaZ, dcut, dmin)]
  return(bonded_pairs)
}
