# WARNING - Generated by {fusen} from dev/flat_crystallography.Rmd: do not edit by hand # nolint: line_length_linter.

#' Extract Unit Cell Metrics and Errors
#' @description Parses unit cell parameters and their uncertainties from CIF content.
#' @param cif_content A data.table containing the lines of a CIF file.
#' @return A one-row data.table with columns for each cell parameter and its error.
#' @import data.table stringr
#' @export
extract_unit_cell_metrics <- function(cif_content) {
  cell_parameters <- c("_cell_length_a", "_cell_length_b", "_cell_length_c", "_cell_angle_alpha", "_cell_angle_beta", "_cell_angle_gamma")
  values <- list(); errors <- list()
  scale_error <- function(value_str, error_str) {
    if (is.na(error_str) || error_str == "") return(NA_real_)
    decimal_pos <- regexpr("\\.", value_str)
    if (decimal_pos == -1) { scaled_error <- as.numeric(error_str) } else {
      decimal_places <- nchar(value_str) - decimal_pos
      scaled_error <- as.numeric(error_str) * 10^(-decimal_places)
    }
    return(scaled_error)
  }
  for (param in cell_parameters) {
    line <- cif_content[V1 %like% param]$V1
    if (length(line) > 0) {
      match_res <- str_match(line, "\\s+([0-9\\.\\-]+)(?:\\(([0-9]+)\\))?")
      if (is.matrix(match_res) && nrow(match_res) > 0 && !any(is.na(match_res))) {
        value_str <- match_res[,2]; error_str <- match_res[,3]
        values[[param]] <- as.numeric(value_str)
        errors[[paste0(param, "_error")]] <- scale_error(value_str, error_str)
      } else { values[[param]] <- NA_real_; errors[[paste0(param, "_error")]] <- NA_real_ }
    } else { values[[param]] <- NA_real_; errors[[paste0(param, "_error")]] <- NA_real_ }
  }
  return(as.data.table(c(values, errors)))
}

#' Extract Atomic Coordinates
#' @description Parses atomic site information (label, coordinates, errors).
#' @param cif_content A data.table containing the lines of a CIF file.
#' @return A data.table where each row corresponds to an atom.
#' @import data.table stringr
#' @export
extract_atomic_coordinates <- function(cif_content) {
  first_header_line_idx <- grep("^_atom_site_fract_x", cif_content$V1)
  if (length(first_header_line_idx)==0) { first_header_line_idx <- grep("^_atom_site_label", cif_content$V1); if (length(first_header_line_idx)==0) return(NULL) }
  loop_start_line_idx <- max(grep("^loop_", cif_content$V1[1:first_header_line_idx]))
  if (is.infinite(loop_start_line_idx)) return(NULL)
  line_indices <- (loop_start_line_idx + 1):nrow(cif_content); headers <- character(); first_data_line_idx <- 0
  for (i in line_indices) { line <- cif_content$V1[i]; if (startsWith(line, "_")) { headers <- c(headers, trimws(line)) } else { first_data_line_idx <- i; break } }
  tags_to_find <- c(label="_atom_site_label", x="_atom_site_fract_x", y="_atom_site_fract_y", z="_atom_site_fract_z", occupancy="_atom_site_occupancy", wyckoff="_atom_site_Wyckoff_symbol", multiplicity="_atom_site_symmetry_multiplicity")
  col_indices <- sapply(tags_to_find, function(tag) { idx <- which(headers == tag); if (length(idx) == 0) NA else idx })
  if (any(is.na(col_indices[c("label", "x", "y", "z")]))) { warning("CIF missing essential atom site tags."); return(NULL) }
  end_candidates <- c(grep("^loop_|^_|^#", cif_content$V1[first_data_line_idx:nrow(cif_content)]), grep("^\\s*$", cif_content$V1[first_data_line_idx:nrow(cif_content)]))
  last_data_line_idx <- if (length(end_candidates) > 0) { first_data_line_idx + min(end_candidates) - 2 } else { nrow(cif_content) }
  if (first_data_line_idx > last_data_line_idx) return(NULL)
  data_lines <- cif_content$V1[first_data_line_idx:last_data_line_idx]
  atom_data <- fread(text = paste(data_lines, collapse="\n"), header=FALSE, sep="auto", quote="")
  parse_vector_with_error <- function(coord_vector) {
    matches <- str_match(coord_vector, "([0-9\\.\\-]+)(?:\\(([0-9]+)\\))?")
    value_str <- matches[, 2]; error_str <- matches[, 3]
    decimal_pos <- regexpr("\\.", value_str); decimal_places <- ifelse(decimal_pos == -1, 0, nchar(value_str) - decimal_pos)
    scaled_error <- as.numeric(error_str) * 10^(-decimal_places)
    return(list(value = as.numeric(value_str), error = scaled_error))
  }
  x_data <- parse_vector_with_error(atom_data[[col_indices["x"]]]); y_data <- parse_vector_with_error(atom_data[[col_indices["y"]]]); z_data <- parse_vector_with_error(atom_data[[col_indices["z"]]])
  wyckoff_multiplicity <- if (!is.na(col_indices["multiplicity"])) { as.numeric(atom_data[[col_indices["multiplicity"]]]) } else { rep(NA_real_, nrow(atom_data)) }
  atomic_coordinates <- data.table(Label=atom_data[[col_indices["label"]]], WychoffMultiplicity=wyckoff_multiplicity, x_a=x_data$value, y_b=y_data$value, z_c=z_data$value, x_error=x_data$error, y_error=y_data$error, z_error=z_data$error)
  return(atomic_coordinates)
}

#' Extract Symmetry Operations from CIF
#' @description Parses symmetry operation definitions from CIF content.
#' @param cif_content A data.table containing the lines of a CIF file.
#' @return A data.table with columns 'x', 'y', and 'z' for each operation.
#' @import data.table stringr
#' @export
extract_symmetry_operations <- function(cif_content) {
  symop_tag <- "_space_group_symop_operation_xyz"; first_header_line_idx <- grep(symop_tag, cif_content$V1)
  if (length(first_header_line_idx) == 0) { symop_tag <- "_symmetry_equiv_pos_as_xyz"; first_header_line_idx <- grep(symop_tag, cif_content$V1); if (length(first_header_line_idx) == 0) return(NULL) }
  loop_start_line_idx <- max(grep("^loop_", cif_content$V1[1:first_header_line_idx])); if (is.infinite(loop_start_line_idx)) return(NULL)
  line_indices <- (loop_start_line_idx + 1):nrow(cif_content); first_data_line_idx <- 0
  for (i in line_indices) { if (!startsWith(cif_content$V1[i], "_")) { first_data_line_idx <- i; break } }; if (first_data_line_idx == 0) return(NULL)
  end_candidates <- c(grep("^loop_|^_|^#", cif_content$V1[first_data_line_idx:nrow(cif_content)]), grep("^\\s*$", cif_content$V1[first_data_line_idx:nrow(cif_content)]))
  last_data_line_idx <- if (length(end_candidates) > 0) { first_data_line_idx + min(end_candidates) - 2 } else { nrow(cif_content) }
  if (first_data_line_idx > last_data_line_idx) return(NULL)
  data_lines <- cif_content$V1[first_data_line_idx:last_data_line_idx]
  cleaned_lines <- trimws(gsub("^'|^\"|'$|\"$", "", trimws(sub("^[0-9]+\\s+", "", data_lines))))
  symmetry_matrix <- str_split_fixed(cleaned_lines, ",", n = 3)
  return(data.table(x = trimws(symmetry_matrix[, 1]), y = trimws(symmetry_matrix[, 2]), z = trimws(symmetry_matrix[, 3])))
}
