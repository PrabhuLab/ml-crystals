# WARNING - Generated by {fusen} from dev/flat_crystallography.Rmd: do not edit by hand # nolint: line_length_linter.

#' Extract Symmetry Operations from CIF
#' @description Parses symmetry operation definitions from CIF content.
#' @param cif_content A data.table containing the lines of a CIF file.
#' @return A data.table with columns 'x', 'y', and 'z' for each operation.
#' @import data.table stringr
#' @export
extract_symmetry_operations <- function(cif_content) {
  symop_tag <- "_space_group_symop_operation_xyz"
  first_header_line_idx <- grep(symop_tag, cif_content$V1)
  if (is.na(first_header_line_idx)) { symop_tag <- "_symmetry_equiv_pos_as_xyz"; first_header_line_idx <- grep(symop_tag, cif_content$V1); if (is.na(first_header_line_idx)) return(NULL) }
  loop_start_line_idx <- max(grep("^loop_", cif_content$V1[1:first_header_line_idx])); if (is.infinite(loop_start_line_idx)) return(NULL)
  line_indices <- (loop_start_line_idx + 1):nrow(cif_content); first_data_line_idx <- 0
  for (i in line_indices) { if (!startsWith(cif_content$V1[i], "_")) { first_data_line_idx <- i; break } }
  if (first_data_line_idx == 0) return(NULL)
  end_candidates <- c(grep("^loop_|^_|^#", cif_content$V1[first_data_line_idx:nrow(cif_content)]), grep("^\\s*$", cif_content$V1[first_data_line_idx:nrow(cif_content)]))
  last_data_line_idx <- if (length(end_candidates) > 0) { first_data_line_idx + min(end_candidates) - 2 } else { nrow(cif_content) }
  if (first_data_line_idx > last_data_line_idx) return(NULL)
  data_lines <- cif_content$V1[first_data_line_idx:last_data_line_idx]
  cleaned_lines <- trimws(gsub("^'|^\"|'$|\"$", "", trimws(sub("^[0-9]+\\s+", "", data_lines))))
  symmetry_matrix <- str_split_fixed(cleaned_lines, ",", n = 3)
  symmetry_dt <- data.table(x = trimws(symmetry_matrix[, 1]), y = trimws(symmetry_matrix[, 2]), z = trimws(symmetry_matrix[, 3]))
  return(symmetry_dt)
}
