You've encountered a common issue when trying to simulate interactive functions within a non-interactive environment like `knitr`, which is used to build R vignettes. The error `locked binding of ‘readline’ cannot be changed` occurs because `knitr` (and R itself, in many contexts) prevents core functions from the `base` package, like `readline`, from being modified. This is a safety feature.

The previous approach to "mock" the `readline` function is not viable in this environment.

Here is a corrected version of the vignette that avoids this error. Instead of trying to modify `readline`, it clearly shows the user how the function is intended to be used interactively (`eval=FALSE`) and then demonstrates the *outcome* by manually applying the same filtering logic that the function uses internally. This achieves the goal of demonstrating the function's behavior without causing an error.

---
title: "Analyzing Crystallography Data with crystract"
author: "Don Ngo"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analyzing Crystallography Data with crystract}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

This vignette demonstrates the core workflow for using the `crystract` package. The goal is to extract structural and chemical information from a Crystallographic Information File (.cif), calculate key geometric properties, and compile the results into a structured format suitable for further analysis. We will walk through the process step-by-step, mirroring the logic of the original development notebook but using the final, packaged functions.

### Setup: Loading the Package

First, we load the `crystract` package, which provides all the necessary functions for our analysis.

```{r setup}
library(crystract)
```

## 1. Loading CIF Data

Instead of manually setting a working directory, we use the packaged data for this demonstration. The `crystract` package includes an example CIF file (`ICSD422.cif`). We can find its path using `system.file()` and then use the package's `read_cif_files()` function to load it into memory.

The function returns a list of `data.table` objects, one for each file path provided. For this example, we will work with the first (and only) element of the list.

```{r load-data}
# Find the path to the example CIF file included in the package
cif_path <- system.file("extdata", "ICSD422.cif", package = "crystract")

# Read the file content into a list of data.tables
cif_data_list <- read_cif_files(cif_path)

# We'll work with the content of the first file
cif_content <- cif_data_list[[1]]

# Let's look at the first few lines of the raw data
head(cif_content)
```

## 2. Extracting Metadata and Unit Cell Parameters

With the CIF data loaded, we can use the `extract_*` family of functions to parse specific pieces of information.

First, we'll extract the basic metadata:

```{r extract-metadata}
database_code <- extract_database_code(cif_content)
chemical_formula <- extract_chemical_formula(cif_content)
space_group_name <- extract_space_group_name(cif_content)
space_group_number <- extract_space_group_number(cif_content)

cat("Database Code:", database_code, "\n")
cat("Chemical Formula:", chemical_formula, "\n")
cat("Space Group:", space_group_name, "(No.", space_group_number, ")\n")
```

Next, we extract the unit cell parameters and their associated errors using `extract_unit_cell_metrics()`.

```{r extract-metrics}
unit_cell_metrics <- extract_unit_cell_metrics(cif_content)
print(unit_cell_metrics)
```

## 3. Extracting Atomic and Symmetry Data

The next step is to get the positions of the asymmetric atoms and the symmetry operations that define the crystal structure.

```{r extract-coords-symm}
# Extract the coordinates of the unique atoms in the asymmetric unit
atomic_coordinates <- extract_atomic_coordinates(cif_content)
print("Asymmetric Atomic Coordinates:")
print(atomic_coordinates)

# Extract the symmetry operations
symmetry_operations <- extract_symmetry_operations(cif_content)
print("Symmetry Operations (first 6 of 48):")
print(head(symmetry_operations))
```

## 4. Generating the Full Crystal Structure

Now we use the asymmetric atoms and symmetry operations to build out the complete set of atoms in the unit cell and then expand this into a 3x3x3 supercell for distance calculations.

```{r generate-structure}
# Apply symmetry operations to generate all atoms in the primary unit cell
transformed_coords <- apply_symmetry_operations(atomic_coordinates, symmetry_operations)
print("Unique atoms in full unit cell (first 6):")
print(head(transformed_coords))

# Expand the unit cell into a 3x3x3 supercell for neighbor calculations
expanded_coords <- expand_transformed_coords(transformed_coords)
print("Atoms in supercell (first 6):")
print(head(expanded_coords))
```

### **Formula Context: Symmetry and Expansion**

#### Symmetry Operations
A symmetry operation transforms an initial atomic coordinate `(x, y, z)` to a new coordinate `(x', y', z')` within the unit cell. This is an affine transformation consisting of a rotation (or reflection) and a translation. In matrix form, this is:

$$
\begin{pmatrix} x' \\ y' \\ z' \end{pmatrix} =
\begin{pmatrix} W_{11} & W_{12} & W_{13} \\ W_{21} & W_{22} & W_{23} \\ W_{31} & W_{32} & W_{33} \end{pmatrix}
\begin{pmatrix} x \\ y \\ z \end{pmatrix} +
\begin{pmatrix} w_1 \\ w_2 \\ w_3 \end{pmatrix}
$$

Or more compactly:
$$ \mathbf{x'} = \mathbf{W}\mathbf{x} + \mathbf{w} $$

Where **x** is the initial fractional coordinate vector, **W** is the rotation/reflection matrix, and **w** is the translation vector. The `apply_symmetry_operations` function applies all of the crystal's symmetry operations to each asymmetric atom to generate the complete set of atoms in the unit cell.

#### Supercell Expansion
The `expand_transformed_coords` function generates a supercell by translating the atoms of the primary unit cell. For a 3x3x3 supercell, each atom at fractional coordinate `(x, y, z)` is translated by integer vectors `(i, j, k)` where `i, j, k` range from -1 to 1. The new coordinates `(x_{exp}, y_{exp}, z_{exp})` are:

$$
\begin{align*}
x_{exp} &= x + i \\
y_{exp} &= y + j \\
z_{exp} &= z + k
\end{align*}
$$

This expansion is necessary to find all nearest neighbors of the atoms in the central unit cell.

## 5. Calculating Geometric Properties

With the full atomic structure generated, we can calculate interatomic distances, identify bonds, count neighbors, and measure bond angles.

### Distances
We calculate the distances from each asymmetric atom to all atoms in the supercell.

```{r calc-distances}
distances <- calculate_distances(atomic_coordinates, expanded_coords, unit_cell_metrics)
print("Calculated Distances (shortest 6):")
print(head(distances[order(Distance)]))
```

### **Formula Context: Interatomic Distance**
In crystallography, the unit cell axes (`a, b, c`) are not always orthogonal, or at 90° to each other. This means we cannot use the simple Pythagorean theorem. Instead, the distance `d` between two atoms at fractional coordinates `(xf1, yf1, zf1)` and `(xf2, yf2, zf2)` is calculated using a formula that accounts for the lengths of the cell axes and cell angles (`α, β, γ`):

$$
d=\sqrt{\begin{aligned}
& a^2(x_{f1}-x_{f2})^2 + b^2(y_{f1}-y_{f2})^2 + c^2(z_{f1}-z_{f2})^2 \\
& + 2ab(x_{f1}-x_{f2})(y_{f1}-y_{f2})\cos\gamma \\
& + 2ac(x_{f1}-x_{f2})(z_{f1}-z_{f2})\cos\beta \\
& + 2bc(y_{f1}-y_{f2})(z_{f1}-z_{f2})\cos\alpha
\end{aligned}}
$$

### Bonding and Neighbor Counts
We use the `minimum_distance` method to identify which atoms are bonded. The `delta` parameter controls the tolerance. Once bonds are identified, we can count the number of nearest neighbors for each atom.

```{r calc-bonding-neighbors}
# Identify bonded pairs
bonded_pairs <- minimum_distance(distances, delta = 0.1)
print("Bonded Pairs (first 6):")
print(head(bonded_pairs))

# Calculate neighbor counts based on the bonded pairs
neighbor_counts <- calculate_neighbor_counts(bonded_pairs)
print("Neighbor Counts:")
print(neighbor_counts)
```

### **Formula Context: Bonding and Neighbors**

#### Determination of Cut-off Distance
To robustly identify the nearest neighbors for each unique atom, the Minimum Distance Method is used. This method defines a custom cut-off distance for each central atom based on its shortest interatomic distance found. A neighboring atom is considered part of the first coordination sphere (i.e., bonded) if its distance `d_i` is less than or equal to this cut-off:
$$
d_i^\text{cut} = (1+\delta) d_i^\text{min}
$$
Here, $d_i^\text{min}$ is the shortest distance from the central atom `i` to any other atom, and `δ` is a relative tolerance parameter. A value of `δ = 0.1` is used, as it has been shown to be effective. This approach is more flexible than using a single fixed cut-off for all atom types.

#### Number of Neighbor Pairs
For any central atom with `n` neighbors, the number of bond angles that can be formed around it is the number of ways to choose two atoms from the set of `n` neighbors. This is calculated using the combination formula:
$$
\binom{n}{2} = \frac{n(n-1)}{2}
$$

### Bond Angles
Using the list of bonded pairs, we can now calculate the bond angles around each central atom.

```{r calc-angles}
bond_angles <- calculate_angles(
  bonded_pairs,
  atomic_coordinates,
  expanded_coords,
  unit_cell_metrics
)
print("Calculated Bond Angles (first 6):")
print(head(bond_angles))
```

### **Formula Context: Bond Angle Calculation**

#### 1. From Fractional to Cartesian Coordinates
To use the standard vector dot product for calculating angles, the fractional coordinates (`x_f, y_f, z_f`) must first be converted into a standard Cartesian system (`x_c, y_c, z_c`) where the axes are orthogonal. This is done via a transformation matrix **M** that accounts for the unit cell parameters:
$$
\begin{pmatrix} x_c \\ y_c \\ z_c \end{pmatrix} = \mathbf{M} \cdot \begin{pmatrix} x_f \\ y_f \\ z_f \end{pmatrix}
$$
With the transformation matrix **M** defined as:
$$
\mathbf{M} = \begin{pmatrix}
a & b \cos\gamma & c \cos\beta \\
0 & b \sin\gamma & \frac{c(\cos\alpha - \cos\beta \cos\gamma)}{\sin\gamma} \\
0 & 0 & \frac{c\sqrt{1-\cos^2\alpha - \cos^2\beta - \cos^2\gamma + 2\cos\alpha\cos\beta\cos\gamma}}{\sin\gamma}
\end{pmatrix}
$$

#### 2. Bond Angle using Cartesian Coordinates
Once the three atoms defining the angle (e.g., A-B-C, with B as the center) are in Cartesian coordinates, we can define the vectors from the central atom to its neighbors: $\vec{u}$ (from B to A) and $\vec{v}$ (from B to C). The angle `θ` between them is given by the dot product formula:
$$
\theta = \arccos\left( \frac{\vec{u} \cdot \vec{v}}{|\vec{u}| \cdot |\vec{v}|} \right)
$$

## 6. Error Propagation

The `crystract` package can also propagate the standard uncertainties from the unit cell parameters and atomic coordinates to our calculated distances and angles.

```{r propagate-errors}
# Propagate errors for interatomic distances
bonded_pairs_with_error <- propagate_distance_error(
  bonded_pairs,
  atomic_coordinates,
  unit_cell_metrics
)
print("Bonded Pairs with Distance Error (first 6):")
print(head(bonded_pairs_with_error))

# Propagate errors for bond angles
bond_angles_with_error <- propagate_angle_error(
  bond_angles,
  atomic_coordinates,
  expanded_coords,
  unit_cell_metrics
)
print("Bond Angles with Angle Error (first 6):")
print(head(bond_angles_with_error))
```

### **Formula Context: Error Propagation**

The uncertainty (`σ_f`) in a calculated value `f` that depends on several variables `x_i` with uncertainties `σ_{x_i}` is found using the sum of squares of the partial derivatives. A critical simplification made here is assuming the input variables (cell parameters, atomic coordinates) are uncorrelated, as the full covariance information is often missing from CIFs.

#### Uncertainty in Interatomic Distance
The uncertainty in the distance, `σ_d`, is calculated by summing the contributions from the uncertainty in each cell parameter and each atomic fractional coordinate. With `Δx = x_f1 - x_f2`, etc., the formula is:
$$
\sigma_d = \sqrt{ \sum_i \left( \frac{\partial d}{\partial p_i} \sigma_{p_i} \right)^2 }
$$
Where `p_i` are the parameters `a, b, c, α, β, γ, x_{f1}, y_{f1}, ...`. The partial derivatives are, for example:
$$
\frac{\partial d}{\partial a} = \frac{1}{2d} \cdot (2a(\Delta x)^2 + 2b(\Delta x)(\Delta y)\cos\gamma + 2c(\Delta x)(\Delta z)\cos\beta)
$$
$$
\frac{\partial d}{\partial \alpha} = \frac{1}{2d} \cdot (-2bc(\Delta y)(\Delta z)\sin\alpha)
$$
$$
\frac{\partial d}{\partial x_{f1}} = -\frac{\partial d}{\partial x_{f2}} = \frac{1}{2d} \cdot (2a^2(\Delta x) + 2ab(\Delta y)\cos\gamma + 2ac(\Delta z)\cos\beta)
$$
And so on for all other parameters.

#### Uncertainty in Bond Angle
Propagating error to the bond angle is a multi-step process.

**Step 1: Propagate initial errors to Cartesian coordinate uncertainties.**
First, the uncertainty for each Cartesian coordinate (`Δx_c, Δy_c, Δz_c`) is calculated based on the errors in the cell parameters and fractional coordinates. For `x_c`:
$$
\Delta x_c = \sqrt{ \left(\frac{\partial x_c}{\partial a} \Delta a\right)^2 + \left(\frac{\partial x_c}{\partial b} \Delta b\right)^2 + \dots + \left(\frac{\partial x_c}{\partial z_f} \Delta z_f\right)^2 }
$$
Where the partial derivatives are, for example:
$$
\frac{\partial x_c}{\partial a} = x_f \quad ; \quad \frac{\partial x_c}{\partial \beta} = -c \sin\beta z_f \quad ; \quad \frac{\partial x_c}{\partial x_f} = a
$$
This is repeated for `Δy_c` and `Δz_c` using their respective (more complex) partial derivatives.

**Step 2: Propagate Cartesian uncertainties to the final angle.**
Next, these Cartesian uncertainties are propagated to the final angle `θ`. This is done via the cosine of the angle, `C = cos(θ) = (\vec{u} \cdot \vec{v}) / (|\vec{u}||\vec{v}|)`. The uncertainty in C, `σ_C`, is found from the uncertainties of the Cartesian components of the vectors, and then the final uncertainty in the angle is:
$$
\sigma_{\theta} = \frac{\sigma_C}{\sqrt{1-C^2}}
$$

## 7. The Full Pipeline: `analyze_cif_files`

While running each step manually is useful for demonstration, the `crystract` package provides a high-level wrapper function, `analyze_cif_files()`, that performs the entire sequence of operations for one or more files.

This is the recommended function for batch processing. It returns a single `data.table` where each row corresponds to a processed CIF file, and the complex results (like coordinates, distances, and angles) are stored in list-columns.

```{r full-pipeline}
# Run the entire pipeline on our example file
analysis_results <- analyze_cif_files(cif_path)

# Let's inspect the structure of the output table.
# It's a single row containing all our results in nested lists.
str(analysis_results, max.level = 2)
```

We can easily access the nested data frames for further analysis. For example, to get the final `bonded_pairs` table with errors:

```{r access-nested-data}
# The result is a list-column, so we access the element with [[1]]
final_bonds <- analysis_results$bonded_pairs[[1]]

print(head(final_bonds))
```

## 8. Interactive Filtering of Results

After calculating properties like bond distances and angles, you may want to focus on a specific chemical environment. The `filter_atoms_by_symbol()` function provides an interactive way to filter these results based on the chemical symbol of a central atom.

This function is designed for use in an interactive R session. It will inspect the specified column (e.g., "Atom1" in a bonded pairs table), find all unique chemical symbols, and prompt you to choose which ones to keep.

Let's see how this would work with our `bonded_pairs_with_error` table. This table contains bonds where 'Sr', 'Si', and 'O' atoms act as the central atom.

```{r, eval=FALSE}
# In an interactive R session, you would run the following code:
filtered_bonds <- filter_atoms_by_symbol(
  data_table = bonded_pairs_with_error,
  atom_col = "Atom1"
)

# After running this, the console would display a prompt like this:
#
# Available base atom symbols found: O, Si, Sr 
# Please enter the chemical symbols you want to filter for, separated by commas (e.g., C,Si,O):
#
```

If you were to type `Si` at the prompt and press Enter, the function would return a new `data.table` containing only the rows where the central atom (`Atom1`) is Silicon.

Since this vignette is non-interactive, we will demonstrate the outcome by manually applying the same filtering logic that the `filter_atoms_by_symbol` function uses internally. This correctly simulates the result of the interactive call without causing an error.

```{r filter-simulation}
# Define the user input we are simulating
user_input <- "Si"
atom_col_to_filter <- "Atom1"
data_to_filter <- bonded_pairs_with_error

# --- Internal logic from filter_atoms_by_symbol() ---
# 1. Process the user's input string
symbols_to_keep <- trimws(strsplit(user_input, ",")[[1]])
symbols_to_keep <- symbols_to_keep[symbols_to_keep != ""]

# 2. Construct the regular expression pattern
# This pattern ensures we match 'Si' but not other elements that start with 'Si'
# (if any existed). It looks for the symbol at the start of the string, followed
# by either the end of the string or a non-alphabetic character.
patterns <- sapply(symbols_to_keep, function(sym) {
  paste0("(^", sym, "$)|(^", sym, "[^A-Za-z])")
})
full_pattern <- paste(patterns, collapse = "|")

# 3. Filter the data.table using the generated regex pattern
filtered_bonds <- data_to_filter[grepl(full_pattern, get(atom_col_to_filter))]
# --- End of internal logic ---

# Display the results of the simulation
print("Original table head (contains bonds centered on different atoms):")
print(bonded_pairs_with_error)
cat("\n")
print("Filtered table (now only contains bonds centered on 'Si1'):")
print(filtered_bonds)
```

The resulting `filtered_bonds` table now contains only the Si-Sr1 and Si-Sr2 bonds originating from the 'Si1' central atom, effectively filtering out the bonds that were centered on 'Sr1'or 'Sr2'. This allows for a focused analysis of specific coordination environments.

This concludes the demonstration of the `crystract` package workflow.
